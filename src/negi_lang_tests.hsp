// Test negi-lang processor.

#runtime "hsp3utf"

#include "negi_lang.hsp"

#module m_negi_lang_tests

#const true 1
#const false 0

#deffunc test_begin
	g_pass = 0
	g_fail = 0
	return

#deffunc test_end \
	local status

	if g_pass == 0 || g_fail > 0 {
		status = "fail"
	} else {
		status = "pass"
	}

	mes "pass " + g_pass
	mes "fail " + g_fail
	mes "status " + status
	return

// 2つの文字列を空白や改行の違いを無視して比較する。
#defcfunc strings_are_roughly_equal var actual, var expected, \
	local equal, local c, local a_len, local x_len, local ai, local xi

	equal = true
	a_len = strlen(actual)
	x_len = strlen(expected)
	repeat
		if ai >= a_len && xi >= x_len {
			break
		}
		if ai < a_len {
			c = peek(actual, ai)
			if c == ' ' || c == '\r' || c == '\n' {
				ai++
				continue
			}
		}
		if xi < x_len {
			c = peek(expected, xi)
			if c == ' ' || c == '\r' || c== '\n' {
				xi++
				continue
			}
		}
		if ai < a_len && xi < x_len {
			if peek(actual, ai) == peek(expected, xi) {
				ai++
				xi++
				continue
			}
		}
		logmes strf("differ at ai=%d, xi=%d", ai, xi)
		equal = false
		break
	loop
	return equal

#deffunc eval_test str name, str src, str x_text_str, int x_exit, \
	local a_text, local x_text, local a_exit

	logmes "[TEST] " + name

	negi_lang_eval_src src, a_exit

	if a_exit != x_exit {
		logmes "Unexpected exit code:"
		logmes "  Expected = " + str(x_exit)
		logmes "  Actual = " + str(a_exit)
		g_fail++
		return
	}

	if a_exit != 0 {
		negi_lang_err_summary a_text
	} else {
		a_text = ""
	}

	x_text = x_text_str
	if strings_are_roughly_equal(a_text, x_text) == false {
		logmes "Unexpected output:"
		logmes "  Expected = " + x_text
		logmes "  Actual = " + a_text
		g_fail++
		return
	}

	g_pass++
	return

#deffunc main

	test_begin

	eval_test "empty", "", "", 0
	eval_test "zero exit code", "0", "", 0
	eval_test "non-zero exit code", "42", "", 42
	eval_test "add", "2 + 3", "", 5
	eval_test "add and sub", "7 - 2 + 3", "", 8
	eval_test "add and mul", "21 / 5 * 2 + 7 % 3", "", 21 / 5 * 2 + 7 \ 3
	eval_test "comparison eq true", "1 == 1", "", 1
	eval_test "comparison eq false", "1 == 2", "", 0
	eval_test "comparison lt true", "1 < 2", "", 1
	eval_test "comparison lt false", "1 < 1", "", 0
	eval_test "comparison le true", "1 <= 1", "", 1
	eval_test "comparison le false", "3 <= 2", "", 0
	eval_test "カッコを含む式", "3 * (1 + (4 - 1))", "", 3 * (1 + (4 - 1))

	eval_test "string ne true", {" "b" != "a" "}, "", 1
	eval_test "string concat", {" "hello, " + "world" == "hello, world" "}, "", 1

	eval_test "syntax err", "1 + + 2", {"
		1:5..1:6 near '+'
			Expected an expression
	"}, 1
	eval_test "計算時に型が混在しているとエラー", {" 0 + "1" "}, {"
		1:4..1:5 near '+'
	  		type error
  	"}, 1
	eval_test "終了コードが整数でなければエラー", {" "a" "}, {"
		1:6..1:6 near ''
  			計算結果は整数値でなければいけません。
	"}, 1

	test_end
	return

#global

	main
