// ネギ言語処理系のテスト

// このスクリプトは、ネギ言語のプログラムをいくつか実行して、その結果が期待通りであるかをチェックする。
// すべての結果が期待通りなら、たぶん処理系は正しいだろう、ということで安心できる。

#runtime "hsp3utf"

#include "negi_lang.hsp"

#module m_negi_lang_tests

#const true 1
#const false 0
#const char_cr 0x0d
#const char_lf 0x0a

#define ctype char_is_space(%1) \
	((%1) == ' ' || (%1) == '\t' || (%1) == char_cr || (%1) == char_lf)

#define ctype char_is_ident(%1) \
	('a' <= (%1) && (%1) <= 'z')

#deffunc negi_test_initialize

	s_toml_file_name = "tests.toml"
	sdim s_toml_src
	dim s_toml_src_len

	// name: テストケースの名前
	// src: ネギ言語のソースコード
	// err: 期待されるエラー出力
	// exit: 期待される終了コード
	sdim s_case_names
	sdim s_case_srcs
	sdim s_case_errs
	dim s_case_exits
	s_case_len = 0

	return

#deffunc negi_test_fail str message, int i

	dialog message + " (位置 " + i + ")", 1
	end 1

#deffunc negi_test_load_toml

	exist s_toml_file_name
	s_toml_src_len = strsize
	if s_toml_src_len < 0 {
		negi_test_fail s_toml_file_name + " が見つかりません", 0
	}

	sdim s_toml_src, s_toml_src_len + 1
	bload s_toml_file_name, s_toml_src, s_toml_src_len
	return

// 空白類やコメントをスキップする。
#deffunc negi_test_parse_spaces var i, \
	local c

	repeat
		if i >= s_toml_src_len {
			break
		}

		c = peek(s_toml_src, i)
		if c == '#' {
			i++
			negi_test_skip_line i
			continue
		}
		if char_is_space(c) == false {
			break
		}

		i++
	loop
	return

// 次の改行までスキップする。
#deffunc negi_test_skip_line var i, \
	local lf, local offset

	sdim lf
	poke lf, 0, char_lf
	offset = instr(s_toml_src, i, lf)
	if offset < 0 {
		i = s_toml_src_len
		return
	}
	assert peek(s_toml_src, i + offset) == char_lf
	i += offset + 1
	return

// 識別子をパースする。
#deffunc negi_test_parse_ident var i, \
	local c

	repeat
		if i >= s_toml_src_len {
			break
		}

		c = peek(s_toml_src, i)
		if char_is_ident(c) == false {
			break
		}

		i++
	loop
	return

// エントリーを解析する。
#deffunc negi_test_parse_entry var i, var key, var value, \
	local start, local offset, local quote

	negi_test_parse_spaces i

	start = i
	negi_test_parse_ident i
	key = strmid(s_toml_src, start, i - start)

	negi_test_parse_spaces i
	if peek(s_toml_src, i) != '=' {
		negi_test_fail "= が必要です", i
	}
	i++
	negi_test_parse_spaces i

	// 引用符は "..", """..""", '''..''' の3種類ある。
	if strmid(s_toml_src, i, 3) == "\"\"\"" {
		quote = "\"\"\""
	} else : if strmid(s_toml_src, i, 3) == "'''" {
		quote = "'''"
	} else : if peek(s_toml_src, i) == '"' {
		quote = "\""
	} else {
		// 引用符なしは改行までの文字列とみなす (TOML の正式な仕様ではない)
		start = i
		negi_test_skip_line i
		value = strmid(s_toml_src, start, i - start)
		return
	}

	// 文字列をパースする。
	i += strlen(quote)
	offset = instr(s_toml_src, i, quote)
	if offset < 0 {
		negi_test_fail "文字列が閉じられていません", i
	}
	value = strmid(s_toml_src, i, offset)
	i += offset + strlen(quote)
	return

#deffunc negi_test_parse_toml \
	local i, local c, local eval_key, local start, local key, local value

	negi_test_parse_spaces i

	repeat
		if i >= s_toml_src_len {
			break
		}

		// [[eval]]
		eval_key = "[[eval]]"
		if strmid(s_toml_src, i, strlen(eval_key)) != eval_key {
			negi_test_fail eval_key + " が必要です", i
		}
		i += strlen(eval_key)
		negi_test_parse_spaces i

		repeat
			if i >= s_toml_src_len {
				break
			}

			c = peek(s_toml_src, i)
			if char_is_ident(c) == false {
				break
			}

			start = i
			negi_test_parse_entry i, key, value
			negi_test_parse_spaces i

			if key == "name" {
				s_case_names(s_case_len) = value
			} else : if key == "src" {
				s_case_srcs(s_case_len) = value
			} else : if key == "err" {
				s_case_errs(s_case_len) = value
			} else : if key == "exit" {
				s_case_exits(s_case_len) = int(value)
			} else {
				negi_test_fail "不明なキー: " + key, start
			}
		loop
		s_case_len++
	loop
	return

#deffunc test_begin
	g_pass = 0
	g_fail = 0
	return

#deffunc test_end \
	local status

	if g_pass == 0 || g_fail > 0 {
		status = "失敗 (詳細はデバッグログを参照)"
	} else {
		status = "成功"
	}

	mes "成功数 " + g_pass
	mes "失敗数 " + g_fail
	mes "結果 " + status
	return

// 2つの文字列を空白や改行の違いを無視して比較する。
#defcfunc strings_are_roughly_equal var actual, var expected, \
	local equal, local c, local a_len, local x_len, local ai, local xi

	equal = true
	a_len = strlen(actual)
	x_len = strlen(expected)
	repeat
		if ai >= a_len && xi >= x_len {
			break
		}
		if ai < a_len {
			c = peek(actual, ai)
			if c == ' ' || c == char_cr || c == char_lf {
				ai++
				continue
			}
		}
		if xi < x_len {
			c = peek(expected, xi)
			if c == ' ' || c == char_cr || c == char_lf {
				xi++
				continue
			}
		}
		if ai < a_len && xi < x_len {
			if peek(actual, ai) == peek(expected, xi) {
				ai++
				xi++
				continue
			}
		}
		logmes strf("differ at ai=%d, xi=%d", ai, xi)
		equal = false
		break
	loop
	return equal

#deffunc eval_test str name, str src, str x_text_str, int x_exit, \
	local a_text, local x_text, local a_exit, local ok

	ok = true
	logmes "[TEST] " + name

	negi_lang_eval_src src, a_exit

	if a_exit != x_exit {
		logmes "終了コードが異なります:"
		logmes "  期待 = " + str(x_exit)
		logmes "  実際 = " + str(a_exit)
		ok = false
	}

	negi_lang_err_summary a_text

	x_text = x_text_str
	if strings_are_roughly_equal(a_text, x_text) == false {
		logmes "出力が異なります:"
		logmes "  期待 = " + x_text
		logmes "  実際 = " + a_text
		ok = false
	}

	if ok {
		g_pass++
	} else {
		g_fail++
	}
	return

#deffunc main

	negi_test_initialize
	negi_test_load_toml
	negi_test_parse_toml

	test_begin

	repeat s_case_len
		eval_test s_case_names(cnt), s_case_srcs(cnt), s_case_errs(cnt), s_case_exits(cnt)
	loop

	eval_test "空のプログラムは何もせず正常終了する", "", "", 0
	eval_test "終了コードをゼロにできる", "0", "", 0
	eval_test "終了コードを非ゼロにできる", "42", "", 42

	eval_test "セミコロンが使える", ";;; 1 ; 2 ;;; 3", "", 3
	eval_test "末尾のセミコロンは式を破棄する", "1 ;;;", "", 0

	eval_test "加算ができる", "2 + 3", "", 5
	eval_test "加算と減算ができる", "7 - 2 + 3", "", 8
	eval_test "加算や乗算などができる", "21 / 5 * 2 + 7 % 3", "", 21 / 5 * 2 + 7 \ 3
	eval_test "マイナスが使える", "-(21 * -1 * 2)", "", 42

	eval_test "比較 == true", "1 == 1", "", 1
	eval_test "比較 == false", "1 == 2", "", 0
	eval_test "比較 < true", "1 < 2", "", 1
	eval_test "比較 < false", "1 < 1", "", 0
	eval_test "比較 <= true", "1 <= 1", "", 1
	eval_test "比較 <= false", "3 <= 2", "", 0
	eval_test "異なる型を等号で比較できる", {" 1 == "1" "}, "", 0
	eval_test "異なる型の大小を比較できる", {" 9 < "1" "}, "", 1

	eval_test "比較 文字列の等号否定 true", {" "b" != "a" "}, "", 1
	eval_test "文字列の加算と比較", {"
		"hello, " + "world" == "hello, world"
	"}, "", 1
	eval_test "文字列から文字をとる", {"
		"ab"[0] + "ab"[1]
	"}, "", 'a' + 'b'

	eval_test "配列の要素を取得できる", "[42][0]", "", 42
	eval_test "任意の長さの配列リテラルを書ける", "[3, 1, 4, 1, 5, 9][4]", "", 5

	eval_test "カッコを含む式", "3 * (1 + (4 - 1))", "", 3 * (1 + (4 - 1))

	eval_test "構文エラー", "1 + * 2", {"
		1:5..1:6 near '*'
			この演算子は前置演算子ではありません。
	"}, 1
	eval_test "パーサーが末尾に到達しなければエラー", "}", {"
		1:1..1:2 near '}'
  			この字句を解釈できませんでした。
	"}, 0
	eval_test "丸カッコの不対応の構文エラー", "(0) + (0 + (0)", {"
		1:7..1:8 near '('
  			丸カッコが閉じられていません。
	"}, 1
	eval_test "角カッコの不対応の構文エラー", "a[a][a[a]", {"
		1:5..1:6 near '['
  			角カッコが閉じられていません。
	"}, 1
	eval_test "式の先頭に不適切なトークンがあるときのエラー", "(", {"
		1:1..1:2 near '('
			丸カッコが閉じられていません。
	"}, 1
	eval_test "式の途中に不適切なトークンがあるときのエラー", "1 + fun", {"
		1:5..1:8 near 'fun'
  			式が必要です。
	"}, 1
	eval_test "前置式が途中で終わっているときのエラー", "*", {"
		1:1..1:2 near '*'
			この演算子は前置演算子ではありません。
	"}, 1
	eval_test "計算時に型が混在しているとエラー", {" 0 + "1" "}, {"
		1:4..1:5 near '+'
	  		type error
  	"}, 1
	eval_test "終了コードが整数でなければエラー", {" "a" "}, {"
		1:6..1:6 near ''
  			計算結果は整数値でなければいけません。
	"}, 1

	eval_test "変数を使える", {"
		let a = 21;
		let b = 2;
		a * b
	"}, "", 42
	eval_test "変数に配列を入れられる", {"
		let a = [1];
		let b = [a];
		b[0][0]
	"}, "", 1
	eval_test "未定義の変数の参照はエラー", {"
		let a = a + 1
	"}, {"
		1:9..1:10 near 'a'
			未定義の変数を使用しています。
	"}, 1
	eval_test "代入できる", {"
		let a = 21;
		a = a * 2;
		a
	"}, "", 42
	eval_test "未定義の変数への代入はエラー", {"
		a = 0
	"}, {"
		1:1..1:2 near 'a'
			未定義の変数を使用しています。
	"}, 1
	eval_test "代入の右辺に term を書ける", {"
		let a = 1;
		a = 0 == 0 ? 2 : 0;
		a
	"}, "", 2
	eval_test "複合代入ができる", {"
		let a = 0;
		a += 250;
		a -= 8;
		a *= 2;
		a /= 2;
		a %= 100;
		a
	"}, "", 42

	eval_test "条件式で then 節が計算される", {"
		0 == 0 ? 1 : 2
	"}, "", 1
	eval_test "条件式で else 節が計算される", {"
		0 != 0 ? 1 : 2
	"}, "", 2
	eval_test "条件式を連鎖できる", {"
		0 != 0 ? 1 : 0 == 0 ? 2 : 3
	"}, "", 2
	eval_test "if 文の中に文を書ける", {"
		let a = 1;
		if (0 == 0) {
			if (a == 1) { a = a + 1 }
			a = a + 1;
		}
		a
	"}, "", 3
	eval_test "else が使える", {"
		let a = 1;
		if (0 != 0) { a = 2 } else { a = 3 }
		a
	"}, "", 3
	eval_test "else-if が使える", {"
		let x = 10;
		let s = "";
		if (x % 15 == 0) {
			s = s + "Fizz Buzz"
		} else if (x % 3 == 0) {
			s = s + "Fizz"
		} else if (x % 5 == 0) {
			s = s + "Buzz"
		} else {
			s = s + "10"
		}
		s == "Buzz"
	"}, "", 1

	eval_test "while が使える", {"
		let i = 0;
		while (i < 10) {
			i = i + 1
		}
		i
	"}, "", 10
	eval_test "break が使える", {"
		let x = 25;
		let p = 2;
		while (p < x) {
			if (x % p == 0) { break }
			p = p + 1
		}
		p
	"}, "", 5
	eval_test "入れ子の while で break できる (2~10 の最小の素因数の総和をとる)", {"
		let s = 0;
		let x = 2;
		while (x < 10) {
			let p = 2;
			while (p < x) {
				if (x % p == 0) { break }
				p = p + 1
			}
			s = s + p;
			x = x + 1;
		}
		s
	"}, "", 2 + 3 + 2 + 5 + 2 + 7 + 2 + 3

	eval_test "整数は関数として呼べない", "1()", {"
		1:2..1:3 near '('
			type error
	"}, 1
	eval_test "組み込み関数を呼べる", "array_len([1, 2, 3])", "", 3

	eval_test "ラムダ式を使える", {"
		let f = fun() { return 42 };
		f()
	"}, "", 42
	eval_test "ラムダ式の本体を式にできる", {"
		let f = fun() 42;
		f()
	"}, "", 42
	eval_test "ラムダ式が引数をとれる", {"
		let f = fun(x) { return x * 2 };
		f(21)
	"}, "", 42
	eval_test "ラムダ式が複数の引数をとれる", {"
		let div = fun(x, y) { return x / y };
		div(420, 10)
	"}, "", 42
	eval_test "ローカル変数に代入できる", {"
		let f = fun(x, y) { x = x + 1; y = y + 2; return x * y };
		f(1, 19)
	"}, "", 42
	eval_test "ラムダ式の中でグローバル変数にアクセスできる", {"
		let x = 2;
		let f = fun(y) { x = x * y };
		f(21);
		x
	"}, "", 42
	eval_test "ラムダ式の中で外側のローカル変数にアクセスできる", {"
		let make_counter = fun(x) {
			return fun(y) {
				x = x + y;
				return x;
			};
		};
		let c = make_counter(0);
		let s = 0;
		s = s * 10 + c(1);
		s = s * 10 + c(1);
		let d = make_counter(0);
		s = s * 10 + d(1);
		s
	"}, "", 121
	eval_test "回帰テスト", {"
		let a = 0;
		let f = fun() {
			a += 1;
			return a;
		};
		let g = fun() {
			let b = f();
			a += b;
		};
		g();
		a
	"}, "", 2

	eval_test "配列が自動で拡張される", {"
		let a = [];
		array_push(a, 1);
		array_push(a, 2);
		array_push(a, 3);
		((a[0] * 10 + a[1]) * 10 + a[2]) * 10 + array_len(a)
	"}, "", 1233
	eval_test "配列の要素に代入できる", {"
		let a = [1];
		let b = a;
		a[0] = 42;
		b[0]
	"}, "", 42

	eval_test "マップが使える", {"
		let map = {};
		map["answer"] = 42;
		map["answer"]
	"}, "", 42
	eval_test "マップの要素を変更できる", {"
		let map = {};
		map["answer"] = 41;
		map["answer"] += 1;
		map["answer"]
	"}, "", 42
	eval_test "マップで複数の要素を使える", {"
		let map = {};
		map["ans"] = 84;
		map["wer"] = 2;
		map["ans"] / map["wer"]
	"}, "", 42
	eval_test "マップで整数をキーにできる", {"
		let map = {};
		map[-1] = 84;
		map[1000000009] = 2;
		map[-1] / map[1000000009]
	"}, "", 42
	eval_test "マップの中にマップや関数を入れられる", {"
		let map = {};
		map["inner"] = {};
		map["inner"]["answer"] = 84;
		map["div"] = fun() 2;
		map["inner"]["answer"] / map["div"]()
	"}, "", 42
	eval_test "マップをオブジェクトとして使える", {"
		let make_counter = fun() {
			let self = {};
			let current = 0;
			self["last"] = fun() current;
			self["next"] = fun() {
				current += 1;
				current
			};
			self
		};

		let counter = make_counter();
		let s = counter["next"]();
		s = s * 10 + counter["last"]();
		s = s * 10 + counter["next"]();
		s = s * 10 + counter["last"]();
		s
	"}, "", 1122

	eval_test "GC のおかげで無限に配列や環境を生成できる", {"
		__dev_heap_make_tiny();
		let f = 0;
		let i = 0;
		while (i < 10) {
			array_push([i, i, i, i], i);
			i += 1;
		}
		0
	"}, "", 0

	eval_test "整数を文字列に変換できる", {"
		int_to_str(0) == "0"
	"}, "", 1
	eval_test "コメントを書ける", {"
		let a = 0;
		// a += 1;
		a
	"}, "", 0

	test_end
	return

#global

	main
