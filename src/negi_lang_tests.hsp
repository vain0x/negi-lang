// ネギ言語処理系のテスト

// このスクリプトは、ネギ言語のプログラムをいくつか実行して、その結果が期待通りであるかをチェックする。
// すべての結果が期待通りなら、たぶん処理系は正しいだろう、ということで安心できる。

#runtime "hsp3utf"

#include "negi_lang.hsp"

#module m_negi_lang_tests

#const true 1
#const false 0
#const char_cr 0x0d
#const char_lf 0x0a

#deffunc test_begin
	g_pass = 0
	g_fail = 0
	return

#deffunc test_end \
	local status

	if g_pass == 0 || g_fail > 0 {
		status = "失敗 (詳細はデバッグログを参照)"
	} else {
		status = "成功"
	}

	mes "成功数 " + g_pass
	mes "失敗数 " + g_fail
	mes "結果 " + status
	return

// 2つの文字列を空白や改行の違いを無視して比較する。
#defcfunc strings_are_roughly_equal var actual, var expected, \
	local equal, local c, local a_len, local x_len, local ai, local xi

	equal = true
	a_len = strlen(actual)
	x_len = strlen(expected)
	repeat
		if ai >= a_len && xi >= x_len {
			break
		}
		if ai < a_len {
			c = peek(actual, ai)
			if c == ' ' || c == char_cr || c == char_lf {
				ai++
				continue
			}
		}
		if xi < x_len {
			c = peek(expected, xi)
			if c == ' ' || c == char_cr || c == char_lf {
				xi++
				continue
			}
		}
		if ai < a_len && xi < x_len {
			if peek(actual, ai) == peek(expected, xi) {
				ai++
				xi++
				continue
			}
		}
		logmes strf("differ at ai=%d, xi=%d", ai, xi)
		equal = false
		break
	loop
	return equal

#deffunc eval_test str name, str src, str x_text_str, int x_exit, \
	local a_text, local x_text, local a_exit, local ok

	ok = true
	logmes "[TEST] " + name

	negi_lang_eval_src src, a_exit

	if a_exit != x_exit {
		logmes "終了コードが異なります:"
		logmes "  期待 = " + str(x_exit)
		logmes "  実際 = " + str(a_exit)
		ok = false
	}

	negi_lang_err_summary a_text

	x_text = x_text_str
	if strings_are_roughly_equal(a_text, x_text) == false {
		logmes "出力が異なります:"
		logmes "  期待 = " + x_text
		logmes "  実際 = " + a_text
		ok = false
	}

	if ok {
		g_pass++
	} else {
		g_fail++
	}
	return

#deffunc main

	test_begin

	eval_test "空のプログラムは何もせず正常終了する", "", "", 0
	eval_test "終了コードをゼロにできる", "0", "", 0
	eval_test "終了コードを非ゼロにできる", "42", "", 42

	eval_test "セミコロンが使える", ";;; 1 ; 2 ;;; 3", "", 3
	eval_test "末尾のセミコロンは式を破棄する", "1 ;;;", "", 0

	eval_test "加算ができる", "2 + 3", "", 5
	eval_test "加算と減算ができる", "7 - 2 + 3", "", 8
	eval_test "加算や乗算などができる", "21 / 5 * 2 + 7 % 3", "", 21 / 5 * 2 + 7 \ 3
	eval_test "マイナスが使える", "-(21 * -1 * 2)", "", 42

	eval_test "比較 == true", "1 == 1", "", 1
	eval_test "比較 == false", "1 == 2", "", 0
	eval_test "比較 < true", "1 < 2", "", 1
	eval_test "比較 < false", "1 < 1", "", 0
	eval_test "比較 <= true", "1 <= 1", "", 1
	eval_test "比較 <= false", "3 <= 2", "", 0
	eval_test "異なる型を等号で比較できる", {" 1 == "1" "}, "", 0
	eval_test "異なる型の大小を比較できる", {" 9 < "1" "}, "", 1

	eval_test "比較 文字列の等号否定 true", {" "b" != "a" "}, "", 1
	eval_test "文字列の加算と比較", {"
		"hello, " + "world" == "hello, world"
	"}, "", 1
	eval_test "文字列から文字をとる", {"
		"ab"[0] + "ab"[1]
	"}, "", 'a' + 'b'

	eval_test "配列の要素を取得できる", "[42][0]", "", 42
	eval_test "任意の長さの配列リテラルを書ける", "[3, 1, 4, 1, 5, 9][4]", "", 5

	eval_test "カッコを含む式", "3 * (1 + (4 - 1))", "", 3 * (1 + (4 - 1))

	eval_test "構文エラー", "1 + * 2", {"
		1:5..1:6 near '*'
			この演算子は前置演算子ではありません。
	"}, 1
	eval_test "パーサーが末尾に到達しなければエラー", "}", {"
		1:1..1:2 near '}'
  			この字句を解釈できませんでした。
	"}, 0
	eval_test "丸カッコの不対応の構文エラー", "(0) + (0 + (0)", {"
		1:7..1:8 near '('
  			丸カッコが閉じられていません。
	"}, 1
	eval_test "角カッコの不対応の構文エラー", "a[a][a[a]", {"
		1:5..1:6 near '['
  			角カッコが閉じられていません。
	"}, 1
	eval_test "計算時に型が混在しているとエラー", {" 0 + "1" "}, {"
		1:4..1:5 near '+'
	  		type error
  	"}, 1
	eval_test "終了コードが整数でなければエラー", {" "a" "}, {"
		1:6..1:6 near ''
  			計算結果は整数値でなければいけません。
	"}, 1

	eval_test "変数を使える", {"
		let a = 21;
		let b = 2;
		a * b
	"}, "", 42
	eval_test "変数に配列を入れられる", {"
		let a = [1];
		let b = [a];
		b[0][0]
	"}, "", 1
	eval_test "未定義の変数の参照はエラー", {"
		let a = a + 1
	"}, {"
		1:9..1:10 near 'a'
			未定義の変数を使用しています。
	"}, 1
	eval_test "代入できる", {"
		let a = 21;
		a = a * 2;
		a
	"}, "", 42
	eval_test "未定義の変数への代入はエラー", {"
		a = 0
	"}, {"
		1:1..1:2 near 'a'
			未定義の変数を使用しています。
	"}, 1
	eval_test "代入の右辺に term を書ける", {"
		let a = 1;
		a = 0 == 0 ? 2 : 0;
		a
	"}, "", 2
	eval_test "複合代入ができる", {"
		let a = 0;
		a += 250;
		a -= 8;
		a *= 2;
		a /= 2;
		a %= 100;
		a
	"}, "", 42

	eval_test "条件式で then 節が計算される", {"
		0 == 0 ? 1 : 2
	"}, "", 1
	eval_test "条件式で else 節が計算される", {"
		0 != 0 ? 1 : 2
	"}, "", 2
	eval_test "条件式を連鎖できる", {"
		0 != 0 ? 1 : 0 == 0 ? 2 : 3
	"}, "", 2
	eval_test "if 文の中に文を書ける", {"
		let a = 1;
		if (0 == 0) {
			if (a == 1) { a = a + 1 }
			a = a + 1;
		}
		a
	"}, "", 3
	eval_test "else が使える", {"
		let a = 1;
		if (0 != 0) { a = 2 } else { a = 3 }
		a
	"}, "", 3
	eval_test "else-if が使える", {"
		let x = 10;
		let s = "";
		if (x % 15 == 0) {
			s = s + "Fizz Buzz"
		} else if (x % 3 == 0) {
			s = s + "Fizz"
		} else if (x % 5 == 0) {
			s = s + "Buzz"
		} else {
			s = s + "10"
		}
		s == "Buzz"
	"}, "", 1

	eval_test "while が使える", {"
		let i = 0;
		while (i < 10) {
			i = i + 1
		}
		i
	"}, "", 10
	eval_test "break が使える", {"
		let x = 25;
		let p = 2;
		while (p < x) {
			if (x % p == 0) { break }
			p = p + 1
		}
		p
	"}, "", 5
	eval_test "入れ子の while で break できる (2~10 の最小の素因数の総和をとる)", {"
		let s = 0;
		let x = 2;
		while (x < 10) {
			let p = 2;
			while (p < x) {
				if (x % p == 0) { break }
				p = p + 1
			}
			s = s + p;
			x = x + 1;
		}
		s
	"}, "", 2 + 3 + 2 + 5 + 2 + 7 + 2 + 3

	eval_test "整数は関数として呼べない", "1()", {"
		1:2..1:3 near '('
			type error
	"}, 1
	eval_test "組み込み関数を呼べる", "array_len([1, 2, 3])", "", 3

	eval_test "ラムダ式を使える", {"
		let f = fun() { return 42 };
		f()
	"}, "", 42
	eval_test "ラムダ式の本体を式にできる", {"
		let f = fun() 42;
		f()
	"}, "", 42
	eval_test "ラムダ式が引数をとれる", {"
		let f = fun(x) { return x * 2 };
		f(21)
	"}, "", 42
	eval_test "ラムダ式が複数の引数をとれる", {"
		let div = fun(x, y) { return x / y };
		div(420, 10)
	"}, "", 42
	eval_test "ローカル変数に代入できる", {"
		let f = fun(x, y) { x = x + 1; y = y + 2; return x * y };
		f(1, 19)
	"}, "", 42
	eval_test "ラムダ式の中でグローバル変数にアクセスできる", {"
		let x = 2;
		let f = fun(y) { x = x * y };
		f(21);
		x
	"}, "", 42
	eval_test "ラムダ式の中で外側のローカル変数にアクセスできる", {"
		let make_counter = fun(x) {
			return fun(y) {
				x = x + y;
				return x;
			};
		};
		let c = make_counter(0);
		let s = 0;
		s = s * 10 + c(1);
		s = s * 10 + c(1);
		let d = make_counter(0);
		s = s * 10 + d(1);
		s
	"}, "", 121

	eval_test "配列が自動で拡張される", {"
		let a = [];
		array_push(a, 1);
		array_push(a, 2);
		array_push(a, 3);
		((a[0] * 10 + a[1]) * 10 + a[2]) * 10 + array_len(a)
	"}, "", 1233
	eval_test "配列の要素に代入できる", {"
		let a = [1];
		let b = a;
		a[0] = 42;
		b[0]
	"}, "", 42

	eval_test "GC のおかげで無限に配列や環境を生成できる", {"
		__dev_heap_make_tiny();
		let f = 0;
		let i = 0;
		while (i < 10) {
			array_push([i, i, i, i], i);
			i += 1;
		}
		0
	"}, "", 0

	eval_test "整数を文字列に変換できる", {"
		int_to_str(0) == "0"
	"}, "", 1

	test_end
	return

#global

	main
