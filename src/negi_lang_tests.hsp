// ネギ言語処理系のテスト

// このスクリプトは、ネギ言語のプログラムをいくつか実行して、その結果が期待通りであるかをチェックする。
// すべての結果が期待通りなら、たぶん処理系は正しいだろう、ということで安心できる。

#runtime "hsp3utf"

#include "negi_lang.hsp"

#module m_negi_lang_tests

#const true 1
#const false 0

#deffunc test_begin
	g_pass = 0
	g_fail = 0
	return

#deffunc test_end \
	local status

	if g_pass == 0 || g_fail > 0 {
		status = "失敗 (詳細はデバッグログを参照)"
	} else {
		status = "成功"
	}

	mes "成功数 " + g_pass
	mes "失敗数 " + g_fail
	mes "結果 " + status
	return

// 2つの文字列を空白や改行の違いを無視して比較する。
#defcfunc strings_are_roughly_equal var actual, var expected, \
	local equal, local c, local a_len, local x_len, local ai, local xi

	equal = true
	a_len = strlen(actual)
	x_len = strlen(expected)
	repeat
		if ai >= a_len && xi >= x_len {
			break
		}
		if ai < a_len {
			c = peek(actual, ai)
			if c == ' ' || c == '\r' || c == '\n' {
				ai++
				continue
			}
		}
		if xi < x_len {
			c = peek(expected, xi)
			if c == ' ' || c == '\r' || c== '\n' {
				xi++
				continue
			}
		}
		if ai < a_len && xi < x_len {
			if peek(actual, ai) == peek(expected, xi) {
				ai++
				xi++
				continue
			}
		}
		logmes strf("differ at ai=%d, xi=%d", ai, xi)
		equal = false
		break
	loop
	return equal

#deffunc eval_test str name, str src, str x_text_str, int x_exit, \
	local a_text, local x_text, local a_exit

	logmes "[TEST] " + name

	negi_lang_eval_src src, a_exit

	if a_exit != x_exit {
		logmes "終了コードが異なります:"
		logmes "  期待 = " + str(x_exit)
		logmes "  実際 = " + str(a_exit)
		g_fail++
		return
	}

	if a_exit != 0 {
		negi_lang_err_summary a_text
	} else {
		a_text = ""
	}

	x_text = x_text_str
	if strings_are_roughly_equal(a_text, x_text) == false {
		logmes "出力が異なります:"
		logmes "  期待 = " + x_text
		logmes "  実際 = " + a_text
		g_fail++
		return
	}

	g_pass++
	return

#deffunc main

	test_begin

	eval_test "空のプログラムは何もせず正常終了する", "", "", 0
	eval_test "終了コードをゼロにできる", "0", "", 0
	eval_test "終了コードを非ゼロにできる", "42", "", 42

	eval_test "加算ができる", "2 + 3", "", 5
	eval_test "加算と減算ができる", "7 - 2 + 3", "", 8
	eval_test "加算や乗算などができる", "21 / 5 * 2 + 7 % 3", "", 21 / 5 * 2 + 7 \ 3
	eval_test "比較 == true", "1 == 1", "", 1
	eval_test "比較 == false", "1 == 2", "", 0
	eval_test "比較 < true", "1 < 2", "", 1
	eval_test "比較 < false", "1 < 1", "", 0
	eval_test "比較 <= true", "1 <= 1", "", 1
	eval_test "比較 <= false", "3 <= 2", "", 0
	eval_test "異なる型を等号で比較できる", {" 1 == "1" "}, "", 0
	eval_test "異なる型の大小を比較できる", {" 9 < "1" "}, "", 1

	eval_test "比較 文字列の等号否定 true", {" "b" != "a" "}, "", 1
	eval_test "文字列の加算と比較", {"
		"hello, " + "world" == "hello, world"
	"}, "", 1
	eval_test "文字列から文字をとる", {"
		"ab"[0] + "ab"[1]
	"}, "", 'a' + 'b'

	eval_test "カッコを含む式", "3 * (1 + (4 - 1))", "", 3 * (1 + (4 - 1))

	eval_test "構文エラー", "1 + + 2", {"
		1:5..1:6 near '+'
			Expected an expression
	"}, 1
	eval_test "丸カッコの不対応の構文エラー", "(a) + (a + (a)", {"
		1:7..1:8 near '('
  			丸カッコが閉じられていません。
	"}, 1
	eval_test "角カッコの不対応の構文エラー", "a[a][a[a]", {"
		1:5..1:6 near '['
  			角カッコが閉じられていません。
	"}, 1
	eval_test "計算時に型が混在しているとエラー", {" 0 + "1" "}, {"
		1:4..1:5 near '+'
	  		type error
  	"}, 1
	eval_test "終了コードが整数でなければエラー", {" "a" "}, {"
		1:6..1:6 near ''
  			計算結果は整数値でなければいけません。
	"}, 1

	test_end
	return

#global

	main
