// ネギ言語処理系

#module m_negi_lang

// -----------------------------------------------
// 真理値
// -----------------------------------------------

#define true 1
#define false 0

// -----------------------------------------------
// トークンの種類
// -----------------------------------------------

// ソースコードの末尾を表すトークン
#enum tk_eof = 0

// ソースコードに使えないトークン
#enum tk_err

// 整数を表すトークン
#enum tk_int

// 識別子を表すトークン
#enum tk_ident

// 左カッコ
#enum tk_paren_l

// 右カッコ
#enum tk_paren_r

// 演算子
#enum tk_op

// -----------------------------------------------
// 式の種類
// -----------------------------------------------

#enum ex_err = 0
#enum ex_int
#enum ex_ident
#enum ex_op

// -----------------------------------------------
// 無効な式番号
// -----------------------------------------------

#const ei_none 0

// -----------------------------------------------
// 演算子の種類
// -----------------------------------------------

#enum op_err = 0
#enum op_add
#enum op_sub
#enum op_mul
#enum op_div
#enum op_mod

// -----------------------------------------------
// 演算子のレベルの種類
// -----------------------------------------------

#enum op_level_add = 0
#enum op_level_mul

// -----------------------------------------------
// 文字の種類の判定
// -----------------------------------------------

// 数字
#define ctype is_digit(%1) ('0' <= (%1) && (%1) <= '9')

// アルファベット
#define ctype is_alphabet(%1) (('a' <= (%1) && (%1) <= 'z') || ('A' <= (%1) && (%1) <= 'Z'))

// 識別子に使える文字
#define ctype is_ident_char(%1) (is_digit(%1) || is_alphabet(%1) || (%1) == '_')

// 演算子に使える文字
#define ctype is_op_char(%1) \
	((%1) == '+' || (%1) == '-' || (%1) == '*' || (%1) == '/' || (%1) == '%%' \
	|| (%1) == '&' || (%1) == '|' || (%1) == '^' || (%1) == '~' || (%1) == '!' \
	|| (%1) == '=' || (%1) == '<' || (%1) == '>' || (%1) == ',' || (%1) == ';' \
	)

// -----------------------------------------------
// 致命的なエラー
// -----------------------------------------------

#define failwith(%1) \
	dialog "FATAL ERROR: " + str(%1) + " \nFILE: " + __FILE__ + "\nLINE: " + __LINE__, 1, "negi-lang" :\
	end 1

// -----------------------------------------------
// 初期化
// -----------------------------------------------

#deffunc negi_lang_begin str src
	// 与えられたソースコード
	g_src = src
	g_src_len = strlen(src)

	// トークンのリスト
	// kind: 種類
	// l: トークンを構成する文字列の開始の位置
	// r: トークンを構成する文字列の終わりの位置
	dim g_tk_kinds
	dim g_tk_ls
	dim g_tk_rs
	g_tk_count = 0

	// 式のリスト
	// kind: 種類
	// int: 式に関連する整数値
	// l, r: 式の左辺と右辺を指す式番号
	dim g_ex_kinds
	dim g_ex_ls
	dim g_ex_rs
	dim g_ex_ints
	sdim g_ex_strs
	g_ex_count = 0

	// プログラム全体からなる式の式番号
	g_ei_root = ei_none

	// 終了コード
	g_eval_exit = 0
	return

// -----------------------------------------------
// 字句解析
// -----------------------------------------------

// ソースコードの位置 l から r までの文字列を種類 kind のトークンとしてリストに追加する。
#deffunc negi_lang_tk_add int kind, int l, int r

	// tk_eof 以外のトークンの長さはゼロでない。さもないと無限ループになるおそれがある。
	assert kind == tk_eof || l < r

 	g_tk_kinds(g_tk_count) = kind
	g_tk_ls(g_tk_count) = l
	g_tk_rs(g_tk_count) = r
	g_tk_count++
	return

// ti 番目のトークンを構成する文字列を取得する。
#defcfunc negi_lang_tk_text int ti
	assert ti < g_tk_count
	return strmid(g_src, g_tk_ls(ti), g_tk_rs(ti) - g_tK_ls(ti))

#deffunc negi_lang_tokenize \
	local c, local l, local r

	assert g_tk_count == 0

	repeat
		l = r

		if l >= g_src_len {
			negi_lang_tk_add tk_eof, l, r
			break
		}

		// 次の文字を変数に入れておく。(先読み)
		c = peek(g_src, l)

		// 空白と改行は無視する。
		if c == ' ' || c == '\t' || c == '\r' || c == '\n' {
			r++
			continue
		}

		if is_digit(c) {
			r++
			repeat
				if r >= g_src_len { break }
				if is_digit(peek(g_src, r)) == false { break }
				r++
			loop

			negi_lang_tk_add tk_int, l ,r
			continue
		}

		if c == '_' || is_alphabet(c) {
			r++
			repeat
				if r >= g_src_len { break }

				c = peek(g_src, r)
				if is_ident_char(c) == false { break }
				r++
			loop

			negi_lang_tk_add tk_ident, l, r
			continue
		}

		if c == '(' {
			r++
			negi_lang_tk_add tk_paren_l, l, r
			continue
		}

		if c == ')' {
			r++
			negi_lang_tk_add tk_paren_r, l, r
			continue
		}

		if is_op_char(c) {
			r++
			repeat
				if r >= g_src_len { break }

				c = peek(g_src, r)
				if is_op_char(c) == false { break }
				r++
			loop
			negi_lang_tk_add tk_op, l, r
			continue
		}

		// 不明な文字
		r++
		negi_lang_tk_add tk_err, l, r
	loop

	assert r == g_src_len
	return

// -----------------------------------------------
// 構文解析
// -----------------------------------------------

// 式を追加して、その式番号を返す。
#defcfunc negi_lang_ex_add int kind
	g_ex_kinds(g_ex_count) = kind
	g_ex_ls(g_ex_count) = ei_none
	g_ex_rs(g_ex_count) = ei_none
	g_ex_ints(g_ex_count) = 0
	g_ex_strs(g_ex_count) = ""
	g_ex_count++
	return g_ex_count - 1

#defcfunc negi_lang_ex_add_int int kind, int value, \
	local ei

	ei = negi_lang_ex_add(kind)
	g_ex_ints(ei) = value
	return ei

#defcfunc negi_lang_ex_add_str int kind, str value, \
	local ei

	ei = negi_lang_ex_add(kind)
	g_ex_strs(ei) = value
	return ei

#defcfunc negi_lang_ex_add_err int ti, str message, \
	local ei

	ei = negi_lang_ex_add(ex_err)
	g_ex_ints(ei) = ti
	g_ex_strs(ei) = message
	return ei

#defcfunc negi_lang_ex_add_bin int op, int l, int r, \
	local ei

	ei = negi_lang_ex_add(ex_op)
	g_ex_ints(ei) = op
	g_ex_ls(ei) = l
	g_ex_rs(ei) = r
	return ei

// アトム式 (1つのトークンからなる式) をパースする。
#defcfunc negi_lang_parse_atom var ti, \
	local value

	if g_tk_kinds(ti) == tk_int {
		value = int(negi_lang_tk_text(ti))
		ti++
		return negi_lang_ex_add_int(ex_int, value)
	}
	if g_tk_kinds(ti) == tk_ident {
		value = negi_lang_tk_text(ti)
		ti++
		return negi_lang_ex_add_str(ex_ident, value)
	}
	return negi_lang_ex_add_err(ti, "Expected an expression")

// トークンが演算子で、指定されたレベルを持つなら、その演算子の種類を返す。
// そうでなければ op_err を返す。
#defcfunc negi_lang_parse_op var ti, int op_level, \
	local op_text

	if g_tk_kinds(ti) != tk_op {
		return op_err
	}

	op_text = negi_lang_tk_text(ti)

	if op_level == op_level_add {
		if op_text == "+" {
			return op_add
		}
		if op_text == "-" {
			return op_sub
		}
	}
	if op_level == op_level_mul {
		if op_text == "*" {
			return op_mul
		}
		if op_text == "/" {
			return op_div
		}
		if op_text == "%" {
			return op_mod
		}
	}
	return op_err

// 指定されたレベルの演算子より一段階結合力が高い演算子の式をパースする。
#defcfunc negi_lang_parse_bin_next var ti, int op_level

	if op_level == op_mul {
		return negi_lang_parse_atom(ti)
	}
	return negi_lang_parse_bin(ti, op_level + 1)

// 指定されたレベルの演算子からなる、2項演算子の式をパースする。
#defcfunc negi_lang_parse_bin var ti, int op_level, \
	local l, local r, local op_text, local op

	l = negi_lang_parse_bin_next(ti, op_level)

	repeat
		if g_tk_kinds(ti) != tk_op {
			break
		}

		op = negi_lang_parse_op(ti, op_level)
		if op == op_err {
			break
		}

		ti++
		r = negi_lang_parse_bin_next(ti, op_level)
		l = negi_lang_ex_add_bin(op, l, r)
	loop
	return l

// 指定されたトークンで始まる式をパースする。
#defcfunc negi_lang_parse_ex var ti
	return negi_lang_parse_bin(ti, op_level_add)

#deffunc negi_lang_parse \
	local ei, local ti

	assert g_ex_count == 0

	// 式番号 ei_none を無効な式を表すものとして登録する。
	ei = negi_lang_ex_add_err(0, "NOT AN EXPRESSION")
	assert ei == ei_none

	ti = 0
	g_ei_root = negi_lang_parse_ex(ti)
	assert g_ei_root != ei_none
	return

// -----------------------------------------------
// 評価
// -----------------------------------------------

// 2項演算の式を計算する。
#defcfunc negi_lang_eval_ex_op int ei, \
	local op, local el, local er

	op = g_ex_ints(ei)
	el = negi_lang_eval_ex(g_ex_ls(ei))
	er = negi_lang_eval_ex(g_ex_rs(ei))

	if op == op_add {
		return el + er
	}
	if op == op_sub {
		return el - er
	}
	if op == op_mul {
		return el * er
	}
	if op == op_div {
		return el / er
	}
	if op == op_mod {
		return el \ er
	}
	logmes "op = " + op
	failwith "Unknown op"

#defcfunc negi_lang_eval_ex int ei

	if g_ex_kinds(ei) == ex_int {
		return g_ex_ints(ei)
	}
	if g_ex_kinds(ei) == ex_op {
		return negi_lang_eval_ex_op(ei)
	}
	return

#deffunc negi_lang_eval
	assert g_ei_root != ei_none

	g_eval_exit = negi_lang_eval_ex(g_ei_root)
	return

// -----------------------------------------------
// ソースコードの実行
// -----------------------------------------------

#deffunc negi_lang_eval_src str src, var out_exit_code
	negi_lang_begin src
	negi_lang_tokenize
	negi_lang_parse
	negi_lang_eval
	out_exit_code = g_eval_exit
	return

#global
