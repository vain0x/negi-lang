// ネギ言語処理系

#module m_negi_lang

// ###############################################
// 汎用
// ###############################################

// -----------------------------------------------
// 真理値
// -----------------------------------------------

#const true 1
#const false 0

// -----------------------------------------------
// 致命的なエラー
// -----------------------------------------------

// ネギ言語処理系のバグに起因するエラーを報告して、異常終了する。
// 入力されたプログラムの問題は、これではなく以下にある「エラー」の仕組みを使って報告する。
#define failwith(%1) \
	dialog "FATAL ERROR: " + str(%1) + " \nFILE: " + __FILE__ + "\nLINE: " + __LINE__, 1, "negi-lang" :\
	end 1

// ###############################################
// 定数
// ###############################################

// -----------------------------------------------
// トークンの種類
// -----------------------------------------------

// ソースコードの末尾を表すトークン
#enum tk_eof = 0

// ソースコードに使えないトークン
#enum tk_err

// 整数を表すトークン
#enum tk_int

// 文字列を表すトークン
#enum tk_str

// 識別子を表すトークン
#enum tk_ident

// 左カッコ
#enum tk_paren_l

// 右カッコ
#enum tk_paren_r

// 演算子
#enum tk_op

// -----------------------------------------------
// 式の種類
// -----------------------------------------------

#enum ex_err = 0
#enum ex_int
#enum ex_str
#enum ex_ident
#enum ex_op

// -----------------------------------------------
// 無効な式番号
// -----------------------------------------------

#const ei_none 0

// -----------------------------------------------
// 演算子の種類
// -----------------------------------------------

#enum op_err = 0
#enum op_eq // == (equal)
#enum op_ne // != (not equal)
#enum op_lt // < (less than)
#enum op_le // <= (less than or equal to)
#enum op_gt // < (greater than)
#enum op_ge // >= (greater than or equal to)
#enum op_add // + (addition)
#enum op_sub // - (subtraction)
#enum op_mul // * (multiplication)
#enum op_div // / (division)
#enum op_mod // % (modulo)

// -----------------------------------------------
// 演算子のレベルの種類
// -----------------------------------------------

#enum op_level_top = 0
#enum op_level_cmp = op_level_top // comparison
#enum op_level_add // additive
#enum op_level_mul // multitive

// -----------------------------------------------
// 命令の種類
// -----------------------------------------------

// エラー
#enum in_err = 0

// 終了
#enum in_exit

// 整数リテラルをスタックにプッシュ
#enum in_push_int

// 文字列リテラルをスタックにプッシュ
#enum in_push_str

// スタック上の2つの要素を交換
#enum in_swap

// 演算
#enum in_op

// -----------------------------------------------
// 値の型タグ
// -----------------------------------------------

#enum ty_err = 0

// 整数。値は整数値そのもの。
#enum ty_int

// 文字列。値は g_heap_strs の要素番号。
#enum ty_str

// ###############################################
// 変数
// ###############################################

// モジュールの中にある、ローカルでない変数をすべて初期化する。
// ローカル変数と区別するため、変数の名前には g_ をつける。
#deffunc negi_lang_begin str src

	// 与えられたソースコード
	g_src = src
	g_src_len = strlen(src)

	// トークンのリスト
	// kind: 種類
	// l: トークンを構成する文字列の開始の位置
	// r: トークンを構成する文字列の終わりの位置
	dim g_tk_kinds
	dim g_tk_ls
	dim g_tk_rs
	g_tk_count = 0

	// 式のリスト
	// kind: 種類
	// int: 式に関連する整数値
	// l, r: 式の左辺と右辺を指す式番号
	// ti: ソースコード上での式の範囲を表すトークン番号
	dim g_ex_kinds
	dim g_ex_ls
	dim g_ex_rs
	dim g_ex_ints
	sdim g_ex_strs
	dim g_ex_tis
	g_ex_count = 0

	// プログラム全体からなる式の式番号
	g_ei_root = ei_none

	// 命令列
	// kind: 命令の種類
	// x: 命令がとる整数型の引数 (1つ目)
	// strs: 命令がとる文字列型の引数
	// ti: 命令に対応するソースコード上での範囲を表すトークン番号
	dim g_in_kinds
	dim g_in_xs
	sdim g_in_strs
	dim g_in_tis
	g_in_count = 0

	// スタック
	// ty: データの型タグ
	// val: データの値
	dim g_stack_tys, 1024
	dim g_stack_vals, 1024
	g_stack_count = 0

	// ヒープ
	sdim g_heap_strs, 16, 1024
	g_heap_str_count = 0

	// プログラムカウンタ (実行中のインストラクション番号)
	g_pc = 0

	// 終了コード
	g_eval_exit = 0

	// エラー
	// l, r: エラーが起こっているソースコード上の位置
	sdim g_err_messages
	dim g_err_ls
	dim g_err_rs
	g_err_count = 0
	return

// ###############################################
// エラー
// ###############################################

// 入力されたプログラムの問題は実行時エラーとして報告する。(failwith は使わない。)
// エラーの報告には、そのエラーが発生した箇所 (ソースコードのどのあたりか) を含める。

// 指定された位置の行番号 (y) と列番号 (x) を計算する。
#deffunc negi_lang_find_pos int i, var out_y, var out_x
	out_y = 0
	out_x = 0
	repeat i
		if peek(g_src, cnt) == '\n' {
			out_y++
			out_x = 0
			continue
		}
		out_x++
	loop
	return

// エラーの一覧を表す文字列を生成する。
#deffunc negi_lang_err_summary var buf, \
	local l, local r, local ly, local lx, local ry, local rx, \
	local near, local msg

	buf = ""
	repeat g_err_count
		l = g_err_ls(cnt)
		r = g_err_rs(cnt)
		negi_lang_find_pos l, ly, lx
		negi_lang_find_pos r, ry, rx

		near = strmid(g_src, l, r - l)
		msg = g_err_messages(cnt)

		buf += strf("%d:%d..%d:%d near '%s'\n  %s\n", 1 + ly, 1 + lx, 1 + ry, 1 + rx, near, msg)
	loop
	return

// 処理中のエラーを追加する。
// l, r: エラーに関連する、ソースコード上の範囲を表す。
#deffunc negi_lang_err_add str message, int l, int r
	g_err_messages(g_err_count) = message
	g_err_ls(g_err_count) = l
	g_err_rs(g_err_count) = r
 	g_err_count++
	return

// ###############################################
// 字句解析
// ###############################################

// ソースコードをトークン (単語や記号などのまとまり) 単位に分割する。
// この工程により、後続の構文解析がやりやすくなる。

// トークンのリストは tk_eof で終わるようにする。
// エラーの報告のため、トークンがソースコードのどの位置にあるかを記録しておく。

// -----------------------------------------------
// 文字の種類の判定
// -----------------------------------------------

// 数字
#define ctype is_digit(%1) ('0' <= (%1) && (%1) <= '9')

// アルファベット
#define ctype is_alphabet(%1) (('a' <= (%1) && (%1) <= 'z') || ('A' <= (%1) && (%1) <= 'Z'))

// 識別子に使える文字
#define ctype is_ident_char(%1) (is_digit(%1) || is_alphabet(%1) || (%1) == '_')

// 演算子に使える文字
#define ctype is_op_char(%1) \
	((%1) == '+' || (%1) == '-' || (%1) == '*' || (%1) == '/' || (%1) == '%%' \
	|| (%1) == '&' || (%1) == '|' || (%1) == '^' || (%1) == '~' || (%1) == '!' \
	|| (%1) == '=' || (%1) == '<' || (%1) == '>' || (%1) == ',' || (%1) == ';' \
	)

// -----------------------------------------------
// トークンリスト
// -----------------------------------------------

// ソースコードの位置 l から r までの文字列を種類 kind のトークンとしてリストに追加する。
#deffunc negi_lang_tk_add int kind, int l, int r

	// tk_eof 以外のトークンの長さはゼロでない。さもないと無限ループになるおそれがある。
	assert kind == tk_eof || l < r

 	g_tk_kinds(g_tk_count) = kind
	g_tk_ls(g_tk_count) = l
	g_tk_rs(g_tk_count) = r
	g_tk_count++
	return

// ti 番目のトークンを構成する文字列を取得する。
#defcfunc negi_lang_tk_text int ti
	assert ti < g_tk_count
	return strmid(g_src, g_tk_ls(ti), g_tk_rs(ti) - g_tk_ls(ti))

// -----------------------------------------------
// 字句解析
// -----------------------------------------------

#deffunc negi_lang_tokenize \
	local c, local l, local r

	assert g_tk_count == 0 // 変数が初期化済みであることを確認する。

	repeat
		// 1回のループで、位置 l から始まる1つのトークンを切り出す。
		// l の次の文字 c からトークンの種類を特定して、
		// そのトークンが広がる範囲の右端まで r を進める。
		// 最終的に、切り出されるトークンは位置 l から r までになるようにする。

		l = r

		if l >= g_src_len {
			negi_lang_tk_add tk_eof, l, r
			break
		}

		// 次の文字を変数に入れておく。(先読み)
		c = peek(g_src, l)

		// 空白と改行は無視する。
		if c == ' ' || c == '\t' || c == '\r' || c == '\n' {
			r++
			continue
		}

		if is_digit(c) {
			r++
			repeat
				if r >= g_src_len { break }
				if is_digit(peek(g_src, r)) == false { break }
				r++
			loop

			negi_lang_tk_add tk_int, l, r
			continue
		}

		if c == '"' {
			r++
			repeat
				if r >= g_src_len { break }
				c = peek(g_src, r)

				if c == '\r' || c == '\n' {
					break
				}
				if c == '"' {
					r++
					break
				}
				r++
			loop

			negi_lang_tk_add tk_str, l, r
			continue
		}

		if c == '_' || is_alphabet(c) {
			r++
			repeat
				if r >= g_src_len { break }

				c = peek(g_src, r)
				if is_ident_char(c) == false { break }
				r++
			loop

			negi_lang_tk_add tk_ident, l, r
			continue
		}

		if c == '(' {
			r++
			negi_lang_tk_add tk_paren_l, l, r
			continue
		}

		if c == ')' {
			r++
			negi_lang_tk_add tk_paren_r, l, r
			continue
		}

		if is_op_char(c) {
			r++
			repeat
				if r >= g_src_len { break }

				c = peek(g_src, r)
				if is_op_char(c) == false { break }
				r++
			loop
			negi_lang_tk_add tk_op, l, r
			continue
		}

		// このとき、文字 c はトークンとして不正なもの。エラーを表すトークンとして追加する。
		r++
		negi_lang_tk_add tk_err, l, r
	loop

	assert r == g_src_len
	return

// ###############################################
// 構文解析
// ###############################################

// トークンのリストに再帰下降構文解析を適用して、抽象構文木を作る。

// -----------------------------------------------
// 式リスト
// -----------------------------------------------

// 式を追加して、その式番号を返す。
#deffunc negi_lang_ex_add int kind, int ti
	g_ex_kinds(g_ex_count) = kind
	g_ex_ls(g_ex_count) = ei_none
	g_ex_rs(g_ex_count) = ei_none
	g_ex_ints(g_ex_count) = 0
	g_ex_strs(g_ex_count) = ""
	g_ex_tis(g_ex_count) = ti
	g_ex_count++
	return

// 整数値をパラメーターに持つ式を追加する。
#defcfunc negi_lang_ex_add_int int kind, int value, int ti

	negi_lang_ex_add kind, ti
	g_ex_ints(g_ex_count - 1) = value
	return g_ex_count - 1

// 文字列をパラメーターに持つ式を追加する。
#defcfunc negi_lang_ex_add_str int kind, str value, int ti

	negi_lang_ex_add kind, ti
	g_ex_strs(g_ex_count - 1) = value
	return g_ex_count - 1

// エラーを表す式を追加する。
#defcfunc negi_lang_ex_add_err str message, int ti

	negi_lang_ex_add ex_err, ti
	g_ex_strs(g_ex_count - 1) = message
	return g_ex_count - 1

// 2項演算を表す式を追加する。
#defcfunc negi_lang_ex_add_bin int op, int l, int r, int ti

	negi_lang_ex_add ex_op, ti
	g_ex_ints(g_ex_count - 1) = op
	g_ex_ls(g_ex_count - 1) = l
	g_ex_rs(g_ex_count - 1) = r
	return g_ex_count - 1

// -----------------------------------------------
// 構文解析
// -----------------------------------------------

// 文字列リテラルをパースする。
#defcfunc negi_lang_parse_str var ti, \
	local text, local text_len, local ei

	assert g_tk_kinds(ti) == tk_str

	text = negi_lang_tk_text(ti)
	text_len = strlen(text)

	assert text_len >= 1 && peek(text, 0) == '"'
	// クオーテーションで終わってないことがあるので注意。
	if peek(text, text_len - 1) == '"' {
		text_len--
	}
	// リテラルの中身
	text = strmid(text, 1, text_len - 1)
	ei = negi_lang_ex_add_str(ex_str, text, ti)
	ti++
	return ei

// アトム式 (分解できない式) をパースする。
#defcfunc negi_lang_parse_atom var ti, \
	local value, local ei, local initial_ti

	if g_tk_kinds(ti) == tk_int {
		value = int(negi_lang_tk_text(ti))
		ei = negi_lang_ex_add_int(ex_int, value, ti)
		ti++
		return ei
	}
	if g_tk_kinds(ti) == tk_str {
		return negi_lang_parse_str(ti)
	}
	if g_tk_kinds(ti) == tk_ident {
		value = negi_lang_tk_text(ti)
		ei = negi_lang_ex_add_str(ex_ident, value, ti)
		ti++
		return ei
	}
	if g_tk_kinds(ti) == tk_paren_l {
		ti++
		ei = negi_lang_parse_ex(ti)
		if g_tk_kinds(ti) != tk_paren_r {
			return negi_lang_ex_add_err("右カッコが必要です。", ti)
		}
		ti++
		return ei
	}
	return negi_lang_ex_add_err("Expected an expression", ti)

// トークンが演算子で、指定されたレベルを持つなら、その演算子の種類を返す。
// そうでなければ op_err を返す。
#defcfunc negi_lang_parse_op var ti, int op_level, \
	local op_text

	if g_tk_kinds(ti) != tk_op {
		return op_err
	}

	op_text = negi_lang_tk_text(ti)

	if op_level == op_level_cmp {
		if op_text == "==" {
			return op_eq
		}
		if op_text == "!=" {
			return op_ne
		}
		if op_text == "<" {
			return op_lt
		}
		if op_text == "<=" {
			return op_le
		}
		if op_text == ">" {
			return op_gt
		}
		if op_text == ">=" {
			return op_ge
		}
	}
	if op_level == op_level_add {
		if op_text == "+" {
			return op_add
		}
		if op_text == "-" {
			return op_sub
		}
	}
	if op_level == op_level_mul {
		if op_text == "*" {
			return op_mul
		}
		if op_text == "/" {
			return op_div
		}
		if op_text == "%" {
			return op_mod
		}
	}
	return op_err

// 指定されたレベルの演算子より一段階結合力が高い演算子の式をパースする。
#defcfunc negi_lang_parse_bin_next var ti, int op_level

	if op_level == op_mul {
		return negi_lang_parse_atom(ti)
	}
	return negi_lang_parse_bin(ti, op_level + 1)

// 指定されたレベルの演算子からなる、2項演算子の式をパースする。
#defcfunc negi_lang_parse_bin var ti, int op_level, \
	local l, local r, local op_text, local op, local op_ti

	l = negi_lang_parse_bin_next(ti, op_level)

	repeat
		if g_tk_kinds(ti) != tk_op {
			break
		}

		op_ti = ti
		op = negi_lang_parse_op(ti, op_level)
		if op == op_err {
			break
		}

		ti++
		r = negi_lang_parse_bin_next(ti, op_level)
		l = negi_lang_ex_add_bin(op, l, r, op_ti)
	loop
	return l

// 指定されたトークンで始まる式をパースする。
#defcfunc negi_lang_parse_ex var ti
	return negi_lang_parse_bin(ti, op_level_top)

// 構文解析を実行する。
#deffunc negi_lang_parse \
	local ei, local ti

	assert g_ex_count == 0

	// 式番号 ei_none を無効な式を表すものとして登録する。
	ei = negi_lang_ex_add_err("NOT AN EXPRESSION", 0)
	assert ei == ei_none

	ti = 0
	if g_tk_kinds(ti) == tk_eof {
		// 空のプログラムは 0 とみなす。
		g_ei_root = negi_lang_ex_add_int(ex_int, 0, ti)
	} else {
		g_ei_root = negi_lang_parse_ex(ti)
	}
	assert g_ei_root != ei_none
	return

// ###############################################
// コード生成
// ###############################################

// 抽象構文木を辿って、中間言語の命令リストを生成する。
// 中間言語はよくあるスタックマシン。

// -----------------------------------------------
// 命令リスト
// -----------------------------------------------

// 命令を追加する。
// ti: この命令と関連するトークン番号
#deffunc negi_lang_in_add int kind, int ti
	g_in_kinds(g_in_count) = kind
	g_in_xs(g_in_count) = 0
	g_in_strs(g_in_count) = ""
	g_in_tis(g_in_count) = ti
	g_in_count++
	return

// 整数値を引数に持つ命令を追加する。
#deffunc negi_lang_in_add_int int kind, int value, int ti

	negi_lang_in_add kind, ti
	g_in_xs(g_in_count - 1) = value
	return

// 文字列を引数に持つ命令を追加する。
#deffunc negi_lang_in_add_str int kind, str value, int ti

	negi_lang_in_add kind, ti
	g_in_strs(g_in_count - 1) = value
	return

// 否定演算の命令を追加する。 (!x ---> x == false)
#deffunc negi_lang_in_add_negate int ti

	negi_lang_in_add_int in_push_int, false, ti
	negi_lang_in_add_int in_op, op_eq, ti
	return

// -----------------------------------------------
// コード生成
// -----------------------------------------------

// 2項演算を行うコードを生成する。
// 評価の実装を簡単にするため、式を適当に変形する。
#deffunc negi_lang_gen_ex_op int ei, \
	local op

	assert g_ex_kinds(ei) == ex_op
	op = g_ex_ints(ei)

	negi_lang_gen_ex g_ex_ls(ei)
	negi_lang_gen_ex g_ex_rs(ei)

	if op == op_ne {
		// l != r ---> !(l == r)
		negi_lang_in_add_int in_op, op_eq, g_ex_tis(ei)
		negi_lang_in_add_negate g_ex_tis(ei)
		return
	}
	if op == op_le {
		// l <= r ---> !(r < l)
		negi_lang_in_add in_swap, g_ex_tis(ei)
		negi_lang_in_add_int in_op, op_lt, g_ex_tis(ei)
		negi_lang_in_add_negate g_ex_tis(ei)
		return
	}
	if op == op_gt {
		// l > r ---> r < l
		negi_lang_in_add in_swap, g_ex_tis(ei)
		negi_lang_in_add_int in_op, op_lt, g_ex_tis(ei)
		return
	}
	if op == op_ge {
		// l >= r ---> !(l < r)
		negi_lang_in_add_int in_op, op_lt, g_ex_tis(ei)
		negi_lang_in_add_negate g_ex_tis(ei)
		return
	}

	negi_lang_in_add_int in_op, op, g_ex_tis(ei)
	return

// 式を計算するコードを生成する。
#deffunc negi_lang_gen_ex int ei

	if g_ex_kinds(ei) == ex_int {
		negi_lang_in_add_int in_push_int, g_ex_ints(ei), g_ex_tis(ei)
		return
	}
	if g_ex_kinds(ei) == ex_str {
		negi_lang_in_add_str in_push_str, g_ex_strs(ei), g_ex_tis(ei)
		return
	}
	if g_ex_kinds(ei) == ex_op {
		negi_lang_gen_ex_op ei
		return
	}
	if g_ex_kinds(ei) == ex_err {
		negi_lang_in_add_str in_err, g_ex_strs(ei), g_ex_tis(ei)
		return
	}
	logmes "ex_kind = " + g_ex_kinds(ei)
	failwith "unknown expression kind"

// コード生成を実行する。
#deffunc negi_lang_gen

	assert g_ei_root != ei_none

	negi_lang_gen_ex g_ei_root

	// スタックにある値を終了コードとして終了する命令を末尾に追加する。
	negi_lang_in_add in_exit, g_tk_count - 1
	return

// ###############################################
// 評価
// ###############################################

// 中間言語のコードを実行して、実際に計算を行う。

// -----------------------------------------------
// スタック
// -----------------------------------------------

// スタックに値を積む。
#deffunc negi_lang_stack_push int ty, int val

	logmes "push ty=" + ty + " val=" + val
	g_stack_tys(g_stack_count) = ty
	g_stack_vals(g_stack_count) = val
	g_stack_count++
	return

// スタックから値を取り出す。
#deffunc negi_lang_stack_pop var out_ty, var out_val

	assert g_stack_count >= 1
	g_stack_count--
	out_ty = g_stack_tys(g_stack_count)
	out_val = g_stack_vals(g_stack_count)
	logmes "pop ty=" + out_ty + " val=" + out_val
	return

// -----------------------------------------------
// ヒープ
// -----------------------------------------------

// ヒープに文字列を追加して、その文字列を指す数値を返す。
#defcfunc negi_lang_heap_str_add str value

	g_heap_strs(g_heap_str_count) = value
	g_heap_str_count++
	return g_heap_str_count - 1

// -----------------------------------------------
// 評価
// -----------------------------------------------

// 異常終了する。
#deffunc negi_lang_eval_abort str message, int ti

	negi_lang_err_add message, g_tk_ls(ti), g_tk_rs(ti)

	// 終了コード 1 で停止させる。
	negi_lang_stack_push ty_int, 1
	g_pc = g_in_count - 1
	assert g_in_kinds(g_pc) == in_exit
	return

// エラー命令を処理する。
#deffunc negi_lang_eval_err int ii

	assert g_in_kinds(ii) == in_err
	negi_lang_eval_abort g_in_strs(ii), g_in_tis(ii)
	return

// スワップ命令を処理する。スタックの上の2つの要素の順番を入れ替える。
#deffunc negi_lang_eval_swap int ii, \
	local val_l, local val_r, local ty_l, local ty_r

	negi_lang_stack_pop ty_l, val_l
	negi_lang_stack_pop ty_r, val_r
	negi_lang_stack_push ty_l, val_l
	negi_lang_stack_push ty_r, val_r
	return

// スタック上の2つの値に演算を適用し、結果をスタックに置く。
#deffunc negi_lang_eval_op int ii, int op, \
	local ty, local val_l, local ty_r, local val_r

	negi_lang_stack_pop ty_r, val_r
	negi_lang_stack_pop ty, val_l

	if op == op_eq {
		if ty != ty_r {
			negi_lang_stack_push ty_int, false
			return
		}
		if ty == ty_int {
			negi_lang_stack_push ty_int, val_l == val_r
			return
		}
		if ty == ty_str {
			negi_lang_stack_push ty_int, g_heap_strs(val_l) == g_heap_strs(val_r)
			return
		}
		negi_lang_eval_abort "type error", g_in_tis(ii)
		return
	}
	assert op != op_ne
	if op == op_lt {
		if ty != ty_r {
			negi_lang_stack_push ty_int, ty < ty_r
			return
		}
		if ty == ty_int {
			negi_lang_stack_push ty_int, val_l < val_r
			return
		}
		if ty == ty_str {
			negi_lang_stack_push ty_int, (g_heap_strs(val_l) != g_heap_strs(val_r)) < 0
			return
		}
		negi_lang_eval_abort "type error", g_in_tis(ii)
		return
	}
	assert op != op_le
	assert op != op_gt
	assert op != op_ge

	if ty != ty_r {
		negi_lang_eval_abort "type error", g_in_tis(ii)
		return
	}

	if op == op_add {
		if ty == ty_int {
			negi_lang_stack_push ty_int, val_l + val_r
			return
		}
		if ty == ty_str {
			val_l = negi_lang_heap_str_add(g_heap_strs(val_l) + g_heap_strs(val_r))
			negi_lang_stack_push ty_str, val_l
			return
		}
		negi_lang_eval_abort "type error", g_in_tis(ii)
		return
	}
	if op == op_sub {
		if ty == ty_int {
			negi_lang_stack_push ty_int, val_l - val_r
			return
		}
		negi_lang_eval_abort "type error", g_in_tis(ii)
		return
	}
	if op == op_mul {
		if ty == ty_int {
			negi_lang_stack_push ty_int, val_l * val_r
			return
		}
		negi_lang_eval_abort "type error", g_in_tis(ii)
		return
	}
	if op == op_div {
		if ty == ty_int {
			negi_lang_stack_push ty_int, val_l / val_r
			return
		}
		negi_lang_eval_abort "type error", g_in_tis(ii)
		return
	}
	if op == op_mod {
		if ty == ty_int {
			negi_lang_stack_push ty_int, val_l \ val_r
			return
		}
		negi_lang_eval_abort "type error", g_in_tis(ii)
		return
	}

	logmes "op = " + op
	failwith "Unknown op"

// 評価のメインループ。
// 終了命令に到達するまで、命令のリストを1つずつ実行する。
#deffunc negi_lang_eval_main \
	local ii, local ty

	repeat
		ii = g_pc
		g_pc++

		if g_in_kinds(ii) == in_push_int {
			negi_lang_stack_push ty_int, g_in_xs(ii)
			continue
		}
		if g_in_kinds(ii) == in_push_str {
			negi_lang_stack_push ty_str, negi_lang_heap_str_add(g_in_strs(ii))
			continue
		}
		if g_in_kinds(ii) == in_swap {
			negi_lang_eval_swap ii
			continue
		}
		if g_in_kinds(ii) == in_op {
			negi_lang_eval_op ii, g_in_xs(ii)
			continue
		}
		if g_in_kinds(ii) == in_err {
			negi_lang_eval_err ii
			continue
		}
		if g_in_kinds(ii) == in_exit {
			// スタックの値を終了コードとする。
			negi_lang_stack_pop ty, g_eval_exit
			if ty != ty_int {
				negi_lang_eval_abort "計算結果は整数値でなければいけません。", g_in_tis(ii)
				continue
			}
			break
		}

		logmes "in_kind = " + g_in_kinds(ii)
		failwith "Unknown instruction kind"
	loop
	return

#deffunc negi_lang_eval

	assert g_in_count != 0

	negi_lang_eval_main
	return

// ###############################################
// 実行
// ###############################################

// ソースコードをコンパイル・実行する。
#deffunc negi_lang_eval_src str src, var out_exit_code

	negi_lang_begin src
	negi_lang_tokenize
	negi_lang_parse
	negi_lang_gen
	negi_lang_eval
	out_exit_code = g_eval_exit
	return

#global
