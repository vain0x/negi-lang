// ネギ言語処理系

#module m_negi_lang

// -----------------------------------------------
// 真理値
// -----------------------------------------------

#const true 1
#const false 0

// -----------------------------------------------
// トークンの種類
// -----------------------------------------------

// ソースコードの末尾を表すトークン
#enum tk_eof = 0

// ソースコードに使えないトークン
#enum tk_err

// 整数を表すトークン
#enum tk_int

// 文字列を表すトークン
#enum tk_str

// 識別子を表すトークン
#enum tk_ident

// 左カッコ
#enum tk_paren_l

// 右カッコ
#enum tk_paren_r

// 演算子
#enum tk_op

// -----------------------------------------------
// 式の種類
// -----------------------------------------------

#enum ex_err = 0
#enum ex_int
#enum ex_str
#enum ex_ident
#enum ex_op

// -----------------------------------------------
// 無効な式番号
// -----------------------------------------------

#const ei_none 0

// -----------------------------------------------
// 演算子の種類
// -----------------------------------------------

#enum op_err = 0
#enum op_eq // == (equal)
#enum op_ne // != (not equal)
#enum op_lt // < (less than)
#enum op_le // <= (less than or equal to)
#enum op_gt // < (greater than)
#enum op_ge // >= (greater than or equal to)
#enum op_add // + (addition)
#enum op_sub // - (subtraction)
#enum op_mul // * (multiplication)
#enum op_div // / (division)
#enum op_mod // % (modulo)

// -----------------------------------------------
// 演算子のレベルの種類
// -----------------------------------------------

#enum op_level_top = 0
#enum op_level_cmp = op_level_top // comparison
#enum op_level_add // additive
#enum op_level_mul // multitive

// -----------------------------------------------
// 値の型タグ
// -----------------------------------------------

#enum ty_err = 0
#enum ty_int
#enum ty_str

// -----------------------------------------------
// 文字の種類の判定
// -----------------------------------------------

// 数字
#define ctype is_digit(%1) ('0' <= (%1) && (%1) <= '9')

// アルファベット
#define ctype is_alphabet(%1) (('a' <= (%1) && (%1) <= 'z') || ('A' <= (%1) && (%1) <= 'Z'))

// 識別子に使える文字
#define ctype is_ident_char(%1) (is_digit(%1) || is_alphabet(%1) || (%1) == '_')

// 演算子に使える文字
#define ctype is_op_char(%1) \
	((%1) == '+' || (%1) == '-' || (%1) == '*' || (%1) == '/' || (%1) == '%%' \
	|| (%1) == '&' || (%1) == '|' || (%1) == '^' || (%1) == '~' || (%1) == '!' \
	|| (%1) == '=' || (%1) == '<' || (%1) == '>' || (%1) == ',' || (%1) == ';' \
	)

// -----------------------------------------------
// 致命的なエラー
// -----------------------------------------------

#define failwith(%1) \
	dialog "FATAL ERROR: " + str(%1) + " \nFILE: " + __FILE__ + "\nLINE: " + __LINE__, 1, "negi-lang" :\
	end 1

// -----------------------------------------------
// 初期化
// -----------------------------------------------

#deffunc negi_lang_begin str src
	// 与えられたソースコード
	g_src = src
	g_src_len = strlen(src)

	// トークンのリスト
	// kind: 種類
	// l: トークンを構成する文字列の開始の位置
	// r: トークンを構成する文字列の終わりの位置
	dim g_tk_kinds
	dim g_tk_ls
	dim g_tk_rs
	g_tk_count = 0

	// 式のリスト
	// kind: 種類
	// int: 式に関連する整数値
	// l, r: 式の左辺と右辺を指す式番号
	dim g_ex_kinds
	dim g_ex_ls
	dim g_ex_rs
	dim g_ex_ints
	sdim g_ex_strs
	g_ex_count = 0

	// プログラム全体からなる式の式番号
	g_ei_root = ei_none

	// 評価中の値
	dim g_val_tys
	dim g_val_ints
	sdim g_val_strs
	g_val_count = 0

	// 終了コード
	g_eval_exit = 0

	// エラー
	// l, r: エラーが起こっているソースコード上の位置
	sdim g_err_messages
	dim g_err_ls
	dim g_err_rs
	g_err_count = 0
	return

// -----------------------------------------------
// エラー
// -----------------------------------------------

// 指定された位置の行番号 (y) と列番号 (x) を計算する。
#deffunc negi_lang_find_pos int i, var out_y, var out_x
	out_y = 0
	out_x = 0
	repeat i
		if peek(g_src, cnt) == '\n' {
			out_y++
			out_x = 0
			continue
		}
		out_x++
	loop
	return

// エラーの一覧を表す文字列を取得する。
#deffunc negi_lang_err_summary var buf, \
	local l, local r, local ly, local lx, local ry, local rx, \
	local near, local msg

	buf = ""
	repeat g_err_count
		l = g_err_ls(cnt)
		r = g_err_rs(cnt)
		negi_lang_find_pos l, ly, lx
		negi_lang_find_pos r, ry, rx

		near = strmid(g_src, l, r - l)
		msg = g_err_messages(cnt)

		buf += strf("%d:%d..%d:%d near '%s'\n  %s\n", 1 + ly, 1 + lx, 1 + ry, 1 + rx, near, msg)
	loop
	return

#deffunc negi_lang_err_add str message, int l, int r
	g_err_messages(g_err_count) = message
	g_err_ls(g_err_count) = l
	g_err_rs(g_err_count) = r
 	g_err_count++
	return

// -----------------------------------------------
// 字句解析
// -----------------------------------------------

// ソースコードの位置 l から r までの文字列を種類 kind のトークンとしてリストに追加する。
#deffunc negi_lang_tk_add int kind, int l, int r

	// tk_eof 以外のトークンの長さはゼロでない。さもないと無限ループになるおそれがある。
	assert kind == tk_eof || l < r

 	g_tk_kinds(g_tk_count) = kind
	g_tk_ls(g_tk_count) = l
	g_tk_rs(g_tk_count) = r
	g_tk_count++
	return

// ti 番目のトークンを構成する文字列を取得する。
#defcfunc negi_lang_tk_text int ti
	assert ti < g_tk_count
	return strmid(g_src, g_tk_ls(ti), g_tk_rs(ti) - g_tK_ls(ti))

#deffunc negi_lang_tokenize \
	local c, local l, local r

	assert g_tk_count == 0

	repeat
		l = r

		if l >= g_src_len {
			negi_lang_tk_add tk_eof, l, r
			break
		}

		// 次の文字を変数に入れておく。(先読み)
		c = peek(g_src, l)

		// 空白と改行は無視する。
		if c == ' ' || c == '\t' || c == '\r' || c == '\n' {
			r++
			continue
		}

		if is_digit(c) {
			r++
			repeat
				if r >= g_src_len { break }
				if is_digit(peek(g_src, r)) == false { break }
				r++
			loop

			negi_lang_tk_add tk_int, l, r
			continue
		}

		if c == '"' {
			r++
			repeat
				if r >= g_src_len { break }
				c = peek(g_src, r)

				if c == '\r' || c == '\n' {
					break
				}
				if c == '"' {
					r++
					break
				}
				r++
			loop

			negi_lang_tk_add tk_str, l, r
			continue
		}

		if c == '_' || is_alphabet(c) {
			r++
			repeat
				if r >= g_src_len { break }

				c = peek(g_src, r)
				if is_ident_char(c) == false { break }
				r++
			loop

			negi_lang_tk_add tk_ident, l, r
			continue
		}

		if c == '(' {
			r++
			negi_lang_tk_add tk_paren_l, l, r
			continue
		}

		if c == ')' {
			r++
			negi_lang_tk_add tk_paren_r, l, r
			continue
		}

		if is_op_char(c) {
			r++
			repeat
				if r >= g_src_len { break }

				c = peek(g_src, r)
				if is_op_char(c) == false { break }
				r++
			loop
			negi_lang_tk_add tk_op, l, r
			continue
		}

		// 不明な文字
		r++
		negi_lang_tk_add tk_err, l, r
	loop

	assert r == g_src_len
	return

// -----------------------------------------------
// 構文解析
// -----------------------------------------------

// 式を追加して、その式番号を返す。
#defcfunc negi_lang_ex_add int kind
	g_ex_kinds(g_ex_count) = kind
	g_ex_ls(g_ex_count) = ei_none
	g_ex_rs(g_ex_count) = ei_none
	g_ex_ints(g_ex_count) = 0
	g_ex_strs(g_ex_count) = ""
	g_ex_count++
	return g_ex_count - 1

#defcfunc negi_lang_ex_add_int int kind, int value, \
	local ei

	ei = negi_lang_ex_add(kind)
	g_ex_ints(ei) = value
	return ei

#defcfunc negi_lang_ex_add_str int kind, str value, \
	local ei

	ei = negi_lang_ex_add(kind)
	g_ex_strs(ei) = value
	return ei

#defcfunc negi_lang_ex_add_err int ti, str message, \
	local ei

	ei = negi_lang_ex_add(ex_err)
	g_ex_ints(ei) = ti
	g_ex_strs(ei) = message
	return ei

#defcfunc negi_lang_ex_add_bin int op, int l, int r, \
	local ei

	ei = negi_lang_ex_add(ex_op)
	g_ex_ints(ei) = op
	g_ex_ls(ei) = l
	g_ex_rs(ei) = r
	return ei

// 文字列リテラルをパースする。
#defcfunc negi_lang_parse_str var ti, \
	local text, local text_len

	assert g_tk_kinds(ti) == tk_str

	text = negi_lang_tk_text(ti)
	text_len = strlen(text)
	ti++

	assert text_len >= 1 && peek(text, 0) == '"'
	// クオーテーションで終わってないことがあるので注意。
	if peek(text, text_len - 1) == '"' {
		text_len--
	}
	// リテラルの中身
	text = strmid(text, 1, text_len - 1)
	return negi_lang_ex_add_str(ex_str, text)

// アトム式 (1つのトークンからなる式) をパースする。
#defcfunc negi_lang_parse_atom var ti, \
	local value

	if g_tk_kinds(ti) == tk_int {
		value = int(negi_lang_tk_text(ti))
		ti++
		return negi_lang_ex_add_int(ex_int, value)
	}
	if g_tk_kinds(ti) == tk_str {
		return negi_lang_parse_str(ti)
	}
	if g_tk_kinds(ti) == tk_ident {
		value = negi_lang_tk_text(ti)
		ti++
		return negi_lang_ex_add_str(ex_ident, value)
	}
	return negi_lang_ex_add_err(ti, "Expected an expression")

// トークンが演算子で、指定されたレベルを持つなら、その演算子の種類を返す。
// そうでなければ op_err を返す。
#defcfunc negi_lang_parse_op var ti, int op_level, \
	local op_text

	if g_tk_kinds(ti) != tk_op {
		return op_err
	}

	op_text = negi_lang_tk_text(ti)

	if op_level == op_level_cmp {
		if op_text == "==" {
			return op_eq
		}
		if op_text == "!=" {
			return op_ne
		}
		if op_text == "<" {
			return op_lt
		}
		if op_text == "<=" {
			return op_le
		}
		if op_text == ">" {
			return op_gt
		}
		if op_text == ">=" {
			return op_ge
		}
	}
	if op_level == op_level_add {
		if op_text == "+" {
			return op_add
		}
		if op_text == "-" {
			return op_sub
		}
	}
	if op_level == op_level_mul {
		if op_text == "*" {
			return op_mul
		}
		if op_text == "/" {
			return op_div
		}
		if op_text == "%" {
			return op_mod
		}
	}
	return op_err

// 指定されたレベルの演算子より一段階結合力が高い演算子の式をパースする。
#defcfunc negi_lang_parse_bin_next var ti, int op_level

	if op_level == op_mul {
		return negi_lang_parse_atom(ti)
	}
	return negi_lang_parse_bin(ti, op_level + 1)

// 指定されたレベルの演算子からなる、2項演算子の式をパースする。
#defcfunc negi_lang_parse_bin var ti, int op_level, \
	local l, local r, local op_text, local op

	l = negi_lang_parse_bin_next(ti, op_level)

	repeat
		if g_tk_kinds(ti) != tk_op {
			break
		}

		op = negi_lang_parse_op(ti, op_level)
		if op == op_err {
			break
		}

		ti++
		r = negi_lang_parse_bin_next(ti, op_level)
		l = negi_lang_ex_add_bin(op, l, r)
	loop
	return l

// 指定されたトークンで始まる式をパースする。
#defcfunc negi_lang_parse_ex var ti
	return negi_lang_parse_bin(ti, op_level_top)

#deffunc negi_lang_parse \
	local ei, local ti

	assert g_ex_count == 0

	// 式番号 ei_none を無効な式を表すものとして登録する。
	ei = negi_lang_ex_add_err(0, "NOT AN EXPRESSION")
	assert ei == ei_none

	ti = 0
	if g_tk_kinds(ti) == tk_eof {
		g_ei_root = negi_lang_ex_add_int(ex_int, 0)
	} else {
		g_ei_root = negi_lang_parse_ex(ti)
	}
	assert g_ei_root != ei_none
	return

// -----------------------------------------------
// 評価
// -----------------------------------------------

#defcfunc negi_lang_val_add int ty
	g_val_tys(g_val_count) = ty
	g_val_ints(g_val_count) = 0
	g_val_strs(g_val_count) = ""
	g_val_count++
	return g_val_count - 1

#defcfunc negi_lang_val_add_bool int value
	if value == false {
		return negi_lang_val_add_int(false)
	}
	return negi_lang_val_add_int(true)

#defcfunc negi_lang_val_add_int int value, \
	local vi

	vi = negi_lang_val_add(ty_int)
	g_val_ints(vi) = value
	return vi

#defcfunc negi_lang_val_add_str str value, \
	local vi

	vi = negi_lang_val_add(ty_str)
	g_val_strs(vi) = value
	return vi

// 構文エラーを実行時エラーとして報告する。
#deffunc negi_lang_eval_verify_syntax \
	local ok, local ei, local ti

	ok = true
	repeat g_ex_count
		ei = cnt
		if ei == ei_none {
			continue
		}
		if g_ex_kinds(ei) == ex_err {
			ti = g_ex_ints(ei)
			negi_lang_err_add g_ex_strs(ei), g_tk_ls(ei), g_tk_rs(ei)
			ok = false
			break
		}
	loop
	return ok

// 2項演算の式を計算する。
#defcfunc negi_lang_eval_ex_op int ei, \
	local op, local vl, local vr, local ty

	op = g_ex_ints(ei)
	vl = negi_lang_eval_ex(g_ex_ls(ei))
	vr = negi_lang_eval_ex(g_ex_rs(ei))
	ty = g_val_tys(vl)

	if ty != g_val_tys(vr) {
		failwith "type error: operands are of different types"
	}

	if op == op_eq {
		if ty == ty_int {
			return negi_lang_val_add_bool(g_val_ints(vl) == g_val_ints(vr))
		}
		if ty == ty_str {
			return negi_lang_val_add_bool(g_val_strs(vl) == g_val_strs(vr))
		}
		failwith "type error"
	}
	if op == op_ne {
		if ty == ty_int {
			return negi_lang_val_add_bool(g_val_ints(vl) != g_val_ints(vr))
		}
		if ty == ty_str {
			return negi_lang_val_add_bool(g_val_strs(vl) != g_val_strs(vr))
		}
		failwith "type error"
	}
	if op == op_lt {
		if ty == ty_int {
			return negi_lang_val_add_bool(g_val_ints(vl) < g_val_ints(vr))
		}
		if ty == ty_str {
			return negi_lang_val_add_bool((g_val_strs(vl) != g_val_strs(vr)) < 0)
		}
		failwith "type error"
	}
	if op == op_le {
		if ty == ty_int {
			return negi_lang_val_add_bool(g_val_ints(vl) <= g_val_ints(vr))
		}
		if ty == ty_str {
			return negi_lang_val_add_bool((g_val_strs(vl) != g_val_strs(vr)) <= 0)
		}
		failwith "type error"
	}
	if op == op_gt {
		if ty == ty_int {
			return negi_lang_val_add_bool(g_val_ints(vl) > g_val_ints(vr))
		}
		if ty == ty_str {
			return negi_lang_val_add_bool((g_val_strs(vl) != g_val_strs(vr)) > 0)
		}
		failwith "type error"
	}
	if op == op_gt {
		if ty == ty_int {
			return negi_lang_val_add_bool(g_val_ints(vl) >= g_val_ints(vr))
		}
		if ty == ty_str {
			return negi_lang_val_add_bool((g_val_strs(vl) != g_val_strs(vr)) >= 0)
		}
		failwith "type error"
	}
	if op == op_add {
		if ty == ty_int {
			return negi_lang_val_add_int(g_val_ints(vl) + g_val_ints(vr))
		}
		if ty == ty_str {
			return negi_lang_val_add_str(g_val_strs(vl) + g_val_strs(vr))
		}
		failwith "type error"
	}
	if op == op_sub {
		if ty == ty_int {
			return negi_lang_val_add_int(g_val_ints(vl) - g_val_ints(vr))
		}
		failwith "type error"
	}
	if op == op_mul {
		if ty == ty_int {
			return negi_lang_val_add_int(g_val_ints(vl) * g_val_ints(vr))
		}
		failwith "type error"
	}
	if op == op_div {
		if ty == ty_int {
			return negi_lang_val_add_int(g_val_ints(vl) / g_val_ints(vr))
		}
		failwith "type error"
	}
	if op == op_mod {
		if ty == ty_int {
			return negi_lang_val_add_int(g_val_ints(vl) \ g_val_ints(vr))
		}
		failwith "type error"
	}

	logmes "op = " + op
	failwith "Unknown op"

#defcfunc negi_lang_eval_ex int ei

	if g_ex_kinds(ei) == ex_int {
		return negi_lang_val_add_int(g_ex_ints(ei))
	}
	if g_ex_kinds(ei) == ex_str {
		return negi_lang_val_add_str(g_ex_strs(ei))
	}
	if g_ex_kinds(ei) == ex_op {
		return negi_lang_eval_ex_op(ei)
	}
	if g_ex_kinds(ei) == ex_err {
		logmes "ERROR!"
		return 0
	}
	logmes "ex_kind = " + g_ex_kinds(ei)
	failwith "Unknown expression kind"

#deffunc negi_lang_eval \
	local vi

	assert g_ei_root != ei_none

	negi_lang_eval_verify_syntax
	if g_err_count != 0 {
		g_eval_exit = 1
		return
	}

	vi = negi_lang_eval_ex(g_ei_root)
	if g_val_tys(vi) != ty_int {
		failwith "type error: the program should return an integer"
	}
	g_eval_exit = g_val_ints(vi)
	return

// -----------------------------------------------
// ソースコードの実行
// -----------------------------------------------

#deffunc negi_lang_eval_src str src, var out_exit_code
	negi_lang_begin src
	negi_lang_tokenize
	negi_lang_parse
	negi_lang_eval
	out_exit_code = g_eval_exit
	return

#global
