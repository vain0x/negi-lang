// ネギ言語処理系

#module m_negi_lang

// ###############################################
// 汎用
// ###############################################

// -----------------------------------------------
// 真理値
// -----------------------------------------------

#const true 1
#const false 0

// -----------------------------------------------
// 文字コード
// -----------------------------------------------

#const char_cr 0x0d
#const char_lf 0x0a

// -----------------------------------------------
// 致命的なエラー
// -----------------------------------------------

// ネギ言語処理系のバグに起因するエラーを報告して、異常終了する。
// 入力されたプログラムの問題は、これではなく以下にある「エラー」の仕組みを使って報告する。
#define failwith(%1) \
	dialog "FATAL ERROR: " + str(%1) + " \nFILE: " + __FILE__ + "\nLINE: " + __LINE__, 1, "negi-lang" :\
	end 1

// -----------------------------------------------
// 警告除け
// -----------------------------------------------

#define declare if false

// -----------------------------------------------
// デバッグ用
// -----------------------------------------------

#ifdef _DEBUG
#define d_trace(%1) logmes (%1)
#define debug(%1) logmes {"%1 = "} + (%1)
#else
#define d_trace(%1) //
#define debug(%1) //
#endif

// ###############################################
// 定数
// ###############################################

// -----------------------------------------------
// トークンの種類
// -----------------------------------------------

// ソースコードに使えないトークン
#enum tok_err = 1

// ソースコードの末尾を表すトークン
#enum tok_eof

// 整数を表すトークン
#enum tok_int

// 文字列を表すトークン
#enum tok_str

// 識別子を表すトークン
#enum tok_ident

// 左丸カッコ
#enum tok_paren_l

// 右丸カッコ
#enum tok_paren_r

// 左角カッコ
#enum tok_bracket_l

// 右角カッコ
#enum tok_bracket_r

// 左波カッコ
#enum tok_brace_l

// 右波カッコ
#enum tok_brace_r

// カンマ
#enum tok_comma

// セミコロン (semicolon)
#enum tok_semi

// 演算子
#enum tok_op

#enum tok_let

#enum tok_if

#enum tok_else

#enum tok_while

#enum tok_break

#enum tok_fun

#enum tok_return

// -----------------------------------------------
// 式の種類
// -----------------------------------------------

#enum exp_err

// 整数リテラル
#enum exp_int

// 文字列リテラル
#enum exp_str

// 配列リテラル
// subexp: 要素
#enum exp_array

// 識別子
#enum exp_ident

// 関数呼び出し
// exp_l: 関数
// subexp: 引数
#enum exp_call

// 演算式
#enum exp_op

// let 式
// int: 定義される識別子のトークン番号
// exp_r: 初期化式
#enum exp_let

// if 文
// exp_cond: 条件
// exp_l, exp_r: then, else
#enum exp_if

// exp_cond: 条件式
// exp_l: 本体
#enum exp_while

#enum exp_break

// ラムダ式
// subexp: 仮引数リスト
// exp_l: 本体
#enum exp_fun

#enum exp_return

// -----------------------------------------------
// 無効な式番号
// -----------------------------------------------

#const exp_i_none 0

// -----------------------------------------------
// 演算子の種類
// -----------------------------------------------

#enum op_err
#enum op_semi // ; (semicolon)
#enum op_set // =
#enum op_set_add // +=
#enum op_set_sub // -=
#enum op_set_mul // *=
#enum op_set_div // /=
#enum op_set_mod // %=
#enum op_eq // == (equal)
#enum op_ne // != (not equal)
#enum op_lt // < (less than)
#enum op_le // <= (less than or equal to)
#enum op_gt // < (greater than)
#enum op_ge // >= (greater than or equal to)
#enum op_add // + (addition)
#enum op_sub // - (subtraction)
#enum op_mul // * (multiplication)
#enum op_div // / (division)
#enum op_mod // % (modulo)
#enum op_index // [] (index)

// 以下の演算子はコンパイラによって生成される。

// 配列の要素の参照を取得する。
#enum op_index_ref

// 配列の末尾に要素を追加する。
#enum op_array_push

// -----------------------------------------------
// 演算子のレベルの種類
// -----------------------------------------------

#enum op_level_set
#enum op_level_cmp // comparison
#enum op_level_add // additive
#enum op_level_mul // multitive

// -----------------------------------------------
// スコープ番号
// -----------------------------------------------

#const scope_i_global 0

// -----------------------------------------------
// 命令の種類
// -----------------------------------------------

// エラー
#enum cmd_err

// 終了
#enum cmd_exit

// ラベル
#enum cmd_label

// スタック上の値が false ならジャンプ
#enum cmd_jump_unless

// 整数リテラルをスタックにプッシュ
#enum cmd_push_int

// 文字列リテラルをスタックにプッシュ
#enum cmd_push_str

// 空の配列を生成してプッシュする
// x: キャパシティ
#enum cmd_push_array

// クロージャを生成してプッシュする
// x: 関数番号
#enum cmd_push_closure

// 外部関数をプッシュする
#enum cmd_push_extern

// ローカル変数の参照セルをプッシュ
// x: 何番目の変数か
// y: 変数が属するスコープ番号
#enum cmd_local_var

// スタックの一番上にある参照セルの値を取得する
#enum cmd_cell_get

// スタックの一番上にある値を、その下にある参照セルに設定する
#enum cmd_cell_set

// スタックの一番上の要素を捨てる
#enum cmd_pop

// スタック上の2つの要素を交換
#enum cmd_swap

// スタックの一番上の要素をもう1つ積む
#enum cmd_dup

// 関数呼び出し
// x: 引数の個数
#enum cmd_call

// 関数から戻る
#enum cmd_return

// 演算
#enum cmd_op

// -----------------------------------------------
// 値の型タグ
// -----------------------------------------------

#enum ty_err

// 整数。値は整数値そのもの。
#enum ty_int

// 文字列。値は s_strs の要素番号。
#enum ty_str

// 配列。値は s_arrays の要素番号。
#enum ty_array

// クロージャ。値は s_closures の要素番号。
#enum ty_closure

// 外部関数。値は s_extern_funs の要素番号。
#enum ty_extern

// 参照セル。値は s_cells の要素番号。
#enum ty_cell

#const global negi_lang_ty_int ty_int

#const global negi_lang_ty_str ty_str

// -----------------------------------------------
// 関数の種類
// -----------------------------------------------

// クロージャ。fun 式によって生成されるオブジェクト。
#enum fun_kind_closure

// 外部関数。extern 宣言によって生成されるオブジェクト。
#enum fun_kind_extern

// -----------------------------------------------
// メモリ管理
// -----------------------------------------------

// 参照セル領域のうちスタックに割り当てられる個数。(1MB)
#const stack_len_min 1024 * 1024 / 4

// 参照セル領域のうちヒープに割り当てられる個数の初期値。(1MB)
#const heap_len_min 1024 * 1024 / 4

// 参照セル領域の長さの既定値。
#const cell_len_min stack_len_min + heap_len_min

#const s_cell_i_stack_max stack_len_min

// ###############################################
// 変数
// ###############################################

// 変数の型や有効範囲が分かりやすいように名前をつける。

// 文字列上の位置や配列の要素番号を表す変数には i をつける。
// 左右があるときは i の代わりに l, r を使う。
// 例えば exp_i は式番号 (式リストの要素番号) を表す。
// 同様に exp_l, exp_r は左側の式番号と右側の式番号を表す。

// モジュールの中にある、ローカル変数ではない変数の名前には s_ をつける。

// 配列は nani_fields と nani_len の組み合わせで管理する。
// 例えば文字列の配列で、各文字列の長さを変数に記録しておくときは、
//   strs: 文字列からなる配列
//   str_lengths: 文字列の長さからなる配列
//   str_len: 文字列リストの要素数
// という3つの変数を使う。(strs(i) と str_length(i) が対応する。)
// これは構造体の配列の代わりになる。

// ###############################################
// ソースコード
// ###############################################

#deffunc negi_lang_src_initialize var src

	// 与えられたソースコード
	s_src = src
	s_src_len = strlen(src)
	return

// ###############################################
// エラー
// ###############################################

// 入力されたプログラムの問題は実行時エラーとして報告する。(failwith は使わない。)
// エラーの報告には、そのエラーが発生した箇所 (ソースコードのどのあたりか) を含める。

#deffunc negi_lang_err_initialize

	// src_l, src_r: エラーが起こっているソースコード上の位置
	sdim s_err_messages
	dim s_err_src_ls
	dim s_err_src_rs
	s_err_len = 0
	return

// 指定された位置の行番号 (y) と列番号 (x) を計算する。
#deffunc negi_lang_find_pos int src_i, var out_y, var out_x
	out_y = 0
	out_x = 0
	repeat src_i
		if peek(s_src, cnt) == char_lf {
			out_y++
			out_x = 0
			continue
		}
		out_x++
	loop
	return

// エラーの一覧を表す文字列を生成する。
#deffunc negi_lang_err_summary var buf, \
	local l, local r, local ly, local lx, local ry, local rx, \
	local text, local msg

	buf = ""
	repeat s_err_len
		l = s_err_src_ls(cnt)
		r = s_err_src_rs(cnt)
		negi_lang_find_pos l, ly, lx
		negi_lang_find_pos r, ry, rx

		text = strmid(s_src, l, r - l)

		buf += strf("%d:%d..%d:%d near '%s'\n  %s\n", 1 + ly, 1 + lx, 1 + ry, 1 + rx, text, s_err_messages(cnt))
	loop
	return

// 処理中のエラーを追加する。
// src_l, src_r: エラーに関連する、ソースコード上の範囲を表す。
#deffunc negi_lang_err_add str message, int src_l, int src_r

	d_trace "err: " + message + ", text = " + strmid(s_src, src_l, src_r - src_l)

	s_err_messages(s_err_len) = message
	s_err_src_ls(s_err_len) = src_l
	s_err_src_rs(s_err_len) = src_r
 	s_err_len++
	return

// ###############################################
// 字句解析
// ###############################################

// ソースコードをトークン (単語や記号などのまとまり) 単位に分割する。
// この工程により、後続の構文解析がやりやすくなる。

// トークンのリストは tok_eof で終わるようにする。
// エラーの報告のため、トークンがソースコードのどの位置にあるかを記録しておく。

// -----------------------------------------------
// 文字の種類の判定
// -----------------------------------------------

// 数字
#define ctype is_digit(%1) ('0' <= (%1) && (%1) <= '9')

// アルファベット
#define ctype is_alphabet(%1) (('a' <= (%1) && (%1) <= 'z') || ('A' <= (%1) && (%1) <= 'Z'))

// 識別子に使える文字
#define ctype is_ident_char(%1) (is_digit(%1) || is_alphabet(%1) || (%1) == '_')

// 演算子に使える文字
#define ctype is_op_char(%1) \
	((%1) == '+' || (%1) == '-' || (%1) == '*' || (%1) == '/' || (%1) == '%%' \
	|| (%1) == '&' || (%1) == '|' || (%1) == '^' || (%1) == '~' || (%1) == '!' \
	|| (%1) == '=' || (%1) == '<' || (%1) == '>' || (%1) == '.' || (%1) == '?' || (%1) == ':' \
	)

// -----------------------------------------------
// トークンリスト
// -----------------------------------------------

#deffunc negi_lang_tok_initialize

	// kind: 種類
	// src_l: トークンを構成する文字列の開始の位置
	// src_r: トークンを構成する文字列の終わりの位置
	dim s_tok_kinds
	dim s_tok_src_ls
	dim s_tok_src_rs
	s_tok_len = 0
	return

// ソースコードの位置 src_l から src_r までの文字列を種類 kind のトークンとしてリストに追加する。
#deffunc negi_lang_tok_add int kind, int src_l, int src_r

	// tok_eof 以外のトークンの長さはゼロでない。さもないと無限ループになるおそれがある。
	assert kind == tok_eof || src_l < src_r

 	s_tok_kinds(s_tok_len) = kind
	s_tok_src_ls(s_tok_len) = src_l
	s_tok_src_rs(s_tok_len) = src_r
	s_tok_len++
	return

// tok_i 番目のトークンを構成する文字列を取得する。
#defcfunc negi_lang_tok_text int tok_i
	assert tok_i < s_tok_len
	return strmid(s_src, s_tok_src_ls(tok_i), s_tok_src_rs(tok_i) - s_tok_src_ls(tok_i))

#defcfunc negi_lang_tok_detect_kind str text

	if text == "let" { return tok_let }
	if text == "if" { return tok_if }
	if text == "else" { return tok_else }
	if text == "while" { return tok_while }
	if text == "break" { return tok_break }
	if text == "fun" { return tok_fun }
	if text == "return" { return tok_return }
	return tok_ident

// -----------------------------------------------
// 字句解析
// -----------------------------------------------

#deffunc negi_lang_tokenize \
	local c, local l, local r, local kind, local text

	assert s_tok_len == 0 // 変数が初期化済みであることを確認する。

	repeat
		// 1回のループで、位置 l から始まる1つのトークンを切り出す。
		// l の次の文字 c からトークンの種類を特定して、
		// そのトークンが広がる範囲の右端まで r を進める。
		// 最終的に、切り出されるトークンは位置 l から r までになるようにする。

		l = r

		if l >= s_src_len {
			negi_lang_tok_add tok_eof, l, r
			break
		}

		// 次の文字を変数に入れておく。(先読み)
		c = peek(s_src, l)

		// 空白と改行は無視する。
		if c == ' ' || c == '\t' || c == char_cr || c == char_lf {
			r++
			continue
		}

		// コメント行を無視する。
		if c == '/' && peek(s_src, l + 1) == '/' {
			r += 2
			repeat
				if r >= s_src_len { break }
				c = peek(s_src, r)
				if c == char_lf { break }
				r++
			loop
			continue
		}

		if is_digit(c) {
			r++
			repeat
				if r >= s_src_len { break }
				if is_digit(peek(s_src, r)) == false { break }
				r++
			loop

			negi_lang_tok_add tok_int, l, r
			continue
		}

		if c == '"' {
			r++
			repeat
				if r >= s_src_len { break }
				c = peek(s_src, r)

				if c == char_cr || c == char_lf {
					break
				}
				if c == '"' {
					r++
					break
				}
				r++
			loop

			negi_lang_tok_add tok_str, l, r
			continue
		}

		if c == '_' || is_alphabet(c) {
			r++
			repeat
				if r >= s_src_len { break }

				c = peek(s_src, r)
				if is_ident_char(c) == false { break }
				r++
			loop

			text = strmid(s_src, l, r - l)
			kind = negi_lang_tok_detect_kind(text)
			negi_lang_tok_add kind, l, r
			continue
		}

		if c == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c == '}' || c == ',' || c == ';' {
			r++
			if c == '(' { kind = tok_paren_l }
			if c == ')' { kind = tok_paren_r }
			if c == '[' { kind = tok_bracket_l }
			if c == ']' { kind = tok_bracket_r }
			if c == '{' { kind = tok_brace_l }
			if c == '}' { kind = tok_brace_r }
			if c == ',' { kind = tok_comma }
			if c == ';' { kind = tok_semi }
			negi_lang_tok_add kind, l, r
			continue
		}

		if is_op_char(c) {
			r++
			repeat
				if r >= s_src_len { break }

				c = peek(s_src, r)
				if is_op_char(c) == false { break }
				r++
			loop
			negi_lang_tok_add tok_op, l, r
			continue
		}

		// このとき、文字 c はトークンとして不正なもの。エラーを表すトークンとして追加する。
		d_trace "tok_err char = " + c
		r++
		negi_lang_tok_add tok_err, l, r
	loop

	assert r == s_src_len
	return

// ###############################################
// 構文解析
// ###############################################

// トークンのリストに再帰下降構文解析を適用して、抽象構文木を作る。

// -----------------------------------------------
// トークンの種類
// -----------------------------------------------

// トークンが項の始まりを表すか否か。
#define ctype tok_leads_term(%1) \
	((%1) == tok_int || (%1) == tok_str || (%1) == tok_ident \
	|| (%1) == tok_paren_l || (%1) == tok_bracket_l || (%1) == tok_fun \
	|| (%1) == tok_op \
	)

// トークンが文の始まりを表すか否か。
#define ctype tok_leads_stmt(%1) \
	(tok_leads_term(%1) || (%1) == tok_let || (%1) == tok_if \
	|| (%1) == tok_while || (%1) == tok_break || (%1) == tok_return \
	)

// -----------------------------------------------
// 式リスト
// -----------------------------------------------

// 式 (抽象構文木のノード) のリスト。

#deffunc negi_lang_exp_initialize

	// kind: 種類
	// int: 式に関連する整数値
	// exp_l, exp_r: 式の左辺と右辺を指す式番号
	// exp_conds: if の条件の式番号
	// tok_i: 式に関連するトークン番号
	dim s_exp_kinds
	dim s_exp_exp_conds
	dim s_exp_exp_ls
	dim s_exp_exp_rs
	dim s_exp_subexp_ls
	dim s_exp_subexp_rs
	dim s_exp_ints
	sdim s_exp_strs
	dim s_exp_tok_is
	s_exp_len = 0

	// プログラム全体からなる式の式番号
	s_exp_i_root = exp_i_none
	return

// 式を追加して、その式番号を返す。
#deffunc negi_lang_exp_add int kind, int tok_i
	s_exp_kinds(s_exp_len) = kind
	s_exp_exp_ls(s_exp_len) = exp_i_none
	s_exp_exp_rs(s_exp_len) = exp_i_none
	s_exp_exp_conds(s_exp_len) = exp_i_none
	s_exp_subexp_ls(s_exp_len) = 0
	s_exp_subexp_rs(s_exp_len) = 0
	s_exp_ints(s_exp_len) = 0
	s_exp_strs(s_exp_len) = ""
	s_exp_tok_is(s_exp_len) = tok_i
	s_exp_len++
	return

// 整数値をパラメーターに持つ式を追加する。
#defcfunc negi_lang_exp_add_int int kind, int value, int tok_i

	negi_lang_exp_add kind, tok_i
	s_exp_ints(s_exp_len - 1) = value
	return s_exp_len - 1

// 文字列をパラメーターに持つ式を追加する。
#defcfunc negi_lang_exp_add_str int kind, str value, int tok_i

	negi_lang_exp_add kind, tok_i
	s_exp_strs(s_exp_len - 1) = value
	return s_exp_len - 1

// エラーを表す式を追加する。
#defcfunc negi_lang_exp_add_err str message, int tok_i

	negi_lang_exp_add exp_err, tok_i
	s_exp_strs(s_exp_len - 1) = message
	return s_exp_len - 1

// 2項演算を表す式を追加する。
// exp_l, exp_r: 左辺と右辺の式番号
#defcfunc negi_lang_exp_add_bin int op, int exp_l, int exp_r, int tok_i

	negi_lang_exp_add exp_op, tok_i
	s_exp_ints(s_exp_len - 1) = op
	s_exp_exp_ls(s_exp_len - 1) = exp_l
	s_exp_exp_rs(s_exp_len - 1) = exp_r
	return s_exp_len - 1

#defcfunc negi_lang_exp_add_subexps int kind, array exp_is, int subexp_len, int tok_i, \
	local subexp_l, local subexp_r

	negi_lang_subexp_add exp_is, subexp_len, subexp_l, subexp_r

	negi_lang_exp_add kind, tok_i
	s_exp_subexp_ls(s_exp_len - 1) = subexp_l
	s_exp_subexp_rs(s_exp_len - 1) = subexp_r
	return s_exp_len - 1

#defcfunc negi_lang_exp_add_if int cond_exp_i, int then_exp_i, int else_exp_i, int tok_i

	negi_lang_exp_add exp_if, tok_i
	s_exp_exp_conds(s_exp_len - 1) = cond_exp_i
	s_exp_exp_ls(s_exp_len - 1) = then_exp_i
	s_exp_exp_rs(s_exp_len - 1) = else_exp_i
	return s_exp_len - 1

// let 式を追加する。
#defcfunc negi_lang_exp_add_let int ident_tok_i, int init_exp_i, int tok_i

	negi_lang_exp_add exp_let, tok_i
	s_exp_ints(s_exp_len - 1) = ident_tok_i
	s_exp_exp_rs(s_exp_len - 1) = init_exp_i
	return s_exp_len - 1

#defcfunc negi_lang_exp_add_while int cond_exp_i, int body_exp_i, int tok_i

	negi_lang_exp_add exp_while, tok_i
	s_exp_exp_conds(s_exp_len - 1) = cond_exp_i
	s_exp_exp_ls(s_exp_len - 1) = body_exp_i
	return s_exp_len - 1

// -----------------------------------------------
// 部分式リスト
// -----------------------------------------------

#deffunc negi_lang_subexp_initialize

	// 部分式のリスト
	// exp_l, exp_r: 式の範囲
	dim s_subexp_exp_is
	s_subexp_len = 0
	return

#deffunc negi_lang_subexp_add array exp_is, int len, var out_subexp_l, var out_subexp_r, \
	local i

	out_subexp_l = s_subexp_len
	out_subexp_r = s_subexp_len + len
	s_subexp_len += len

	repeat len
		i = len - 1 - cnt
		s_subexp_exp_is(out_subexp_l + i) = exp_is(i)
	loop
	return

// -----------------------------------------------
// 構文解析
// -----------------------------------------------

// 文字列リテラルをパースする。
#defcfunc negi_lang_parse_str var tok_i, \
	local text, local text_len, local exp_i

	assert s_tok_kinds(tok_i) == tok_str

	text = negi_lang_tok_text(tok_i)
	text_len = strlen(text)

	assert text_len >= 1 && peek(text, 0) == '"'
	// クオーテーションで終わってないことがあるので注意。
	if peek(text, text_len - 1) == '"' {
		text_len--
	}
	// リテラルの中身
	text = strmid(text, 1, text_len - 1)
	exp_i = negi_lang_exp_add_str(exp_str, text, tok_i)
	tok_i++
	return exp_i

// カンマで区切られた term の並びをパースする。
#deffunc negi_lang_parse_list var tok_i, int bracket_tok_i, array out_exp_is, var out_subexp_len, \
	local exp_i, local len, local kind, local item_tok_i

	len = 0
	repeat
		item_tok_i = tok_i
		kind = s_tok_kinds(tok_i)
		if tok_leads_term(kind) == false {
			break
		}

		exp_i = negi_lang_parse_term(tok_i)
		out_exp_is(len) = exp_i
		len++

		if s_tok_kinds(tok_i) != tok_comma {
			break
		}
		tok_i++
	loop

	out_subexp_len = len
	return

#defcfunc negi_lang_parse_array var tok_i, \
	local exp_is, local subexp_len, local bracket_tok_i, local exp_i

	bracket_tok_i = tok_i
	tok_i++

	negi_lang_parse_list tok_i, bracket_tok_i, exp_is, subexp_len
	exp_i = negi_lang_exp_add_subexps(exp_array, exp_is, subexp_len, bracket_tok_i)

	if s_tok_kinds(tok_i) != tok_bracket_r {
		return negi_lang_exp_add_err("角カッコが閉じられていません。", bracket_tok_i)
	}
	tok_i++
	return exp_i

#defcfunc negi_lang_parse_block var tok_i, \
	local brace_tok_i, local exp_i

	assert s_tok_kinds(tok_i) == tok_brace_l
	brace_tok_i = tok_i
	tok_i++

	exp_i = negi_lang_parse_exp(tok_i)

	if s_tok_kinds(tok_i) != tok_brace_r {
		return negi_lang_exp_add_err("波カッコが閉じられていません。", brace_tok_i)
	}
	tok_i++
	return exp_i

#defcfunc negi_lang_parse_if var tok_i, \
	local if_tok_i, local cond_exp_i, local then_exp_i, local else_exp_i

	assert s_tok_kinds(tok_i) == tok_if
	if_tok_i = tok_if
	tok_i++

	if s_tok_kinds(tok_i) != tok_paren_l {
		return negi_lang_exp_add_err("丸カッコが必要です。", tok_i)
	}
	cond_exp_i = negi_lang_parse_atom(tok_i)

	if s_tok_kinds(tok_i) != tok_brace_l {
		return negi_lang_exp_add_err("波カッコが必要です。", tok_i)
	}
	then_exp_i = negi_lang_parse_block(tok_i)

	if s_tok_kinds(tok_i) == tok_else {
		tok_i++

		if s_tok_kinds(tok_i) == tok_if {
			else_exp_i = negi_lang_parse_if(tok_i)
		} else : if s_tok_kinds(tok_i) == tok_brace_l {
			else_exp_i = negi_lang_parse_block(tok_i)
		} else {
			else_exp_i = negi_lang_exp_add_err("if または波カッコが必要です。", tok_i)
		}
	} else {
		// if (p) { x } ---> if (p) { x } else { 0 }
		else_exp_i = negi_lang_exp_add_int(exp_int, 0, if_tok_i)
	}

	return negi_lang_exp_add_if(cond_exp_i, then_exp_i, else_exp_i, if_tok_i)

#defcfunc negi_lang_parse_while var tok_i, \
	local while_tok_i, local cond_exp_i, local body_exp_i

	assert s_tok_kinds(tok_i) == tok_while
	while_tok_i = tok_if
	tok_i++

	if s_tok_kinds(tok_i) != tok_paren_l {
		return negi_lang_exp_add_err("丸カッコが必要です。", tok_i)
	}
	cond_exp_i = negi_lang_parse_atom(tok_i)

	if s_tok_kinds(tok_i) != tok_brace_l {
		return negi_lang_exp_add_err("波カッコが必要です。", tok_i)
	}
	body_exp_i = negi_lang_parse_block(tok_i)

	return negi_lang_exp_add_while(cond_exp_i, body_exp_i, while_tok_i)

#defcfunc negi_lang_parse_break var tok_i, \
	local break_tok_i

	assert s_tok_kinds(tok_i) == tok_break
	break_tok_i = tok_i
	tok_i++

	return negi_lang_exp_add_int(exp_break, 0, break_tok_i)

#defcfunc negi_lang_parse_fun var tok_i, \
	local fun_tok_i, local paren_tok_i, local exp_is, local subexp_len, \
	local body_exp_i, local fun_exp_i

	assert s_tok_kinds(tok_i) == tok_fun
	fun_tok_i = tok_i
	tok_i++

	if s_tok_kinds(tok_i) != tok_paren_l {
		return negi_lang_exp_add_err("仮引数リストが必要です。", tok_i)
	}
	paren_tok_i = tok_i
	tok_i++

	negi_lang_parse_list tok_i, paren_tok_i, exp_is, subexp_len

	if s_tok_kinds(tok_i) != tok_paren_r {
		return negi_lang_exp_add_err("丸カッコが閉じられていません。", paren_tok_i)
	}
	tok_i++

	if s_tok_kinds(tok_i) == tok_brace_l {
		body_exp_i = negi_lang_parse_block(tok_i)
	} else {
		body_exp_i = negi_lang_parse_term(tok_i)
	}

	fun_exp_i = negi_lang_exp_add_subexps(exp_fun, exp_is, subexp_len, fun_tok_i)
	s_exp_exp_ls(fun_exp_i) = body_exp_i

	return fun_exp_i

#defcfunc negi_lang_parse_return var tok_i, \
	local return_tok_i, local exp_i, local exp_l

	assert s_tok_kinds(tok_i) == tok_return
	return_tok_i = tok_i
	tok_i++

	if tok_leads_term(s_tok_kinds(tok_i)) {
		exp_l = negi_lang_parse_term(tok_i)
	} else {
		exp_l = negi_lang_exp_add_int(exp_int, 0, return_tok_i)
	}

	exp_i = negi_lang_exp_add_int(exp_return, 0, return_tok_i)
	s_exp_exp_ls(exp_i) = exp_l
	return exp_i

#defcfunc negi_lang_parse_atom var tok_i, \
	local kind, local value, local exp_i, local op_tok_i, local err_tok_i

	kind = s_tok_kinds(tok_i)
	if kind == tok_int {
		value = int(negi_lang_tok_text(tok_i))
		exp_i = negi_lang_exp_add_int(exp_int, value, tok_i)
		tok_i++
		return exp_i
	}
	if kind == tok_str {
		return negi_lang_parse_str(tok_i)
	}
	if kind == tok_ident {
		value = negi_lang_tok_text(tok_i)
		exp_i = negi_lang_exp_add_str(exp_ident, value, tok_i)
		tok_i++
		return exp_i
	}
	if kind == tok_paren_l {
		op_tok_i = tok_i
		tok_i++
		exp_i = negi_lang_parse_term(tok_i)
		if s_tok_kinds(tok_i) != tok_paren_r {
			return negi_lang_exp_add_err("丸カッコが閉じられていません。", op_tok_i)
		}
		tok_i++
		return exp_i
	}
	if kind == tok_bracket_l {
		return negi_lang_parse_array(tok_i)
	}

	// 項のパースができなかったので、次のトークンが項の始まりを表すものではないことが分かる。
	err_tok_i = tok_i
	if kind != tok_eof {
		tok_i++
	}
	return negi_lang_exp_add_err("式が必要です。", err_tok_i)

// 後置式をパースする。
// ここでは `x[i]` のように式の後ろにつく種類の式を後置式を呼んでいる。
#defcfunc negi_lang_parse_suffix var tok_i, \
	local exp_l, local exp_r, local op_tok_i, \
	local exp_is, local subexp_len

	exp_l = negi_lang_parse_atom(tok_i)

	repeat
		if s_tok_kinds(tok_i) == tok_bracket_l {
			op_tok_i = tok_i
			tok_i++

			exp_r = negi_lang_parse_term(tok_i)

			if s_tok_kinds(tok_i) != tok_bracket_r {
				exp_l = negi_lang_exp_add_err("角カッコが閉じられていません。", op_tok_i)
				break
			}
			tok_i++

			exp_l = negi_lang_exp_add_bin(op_index, exp_l, exp_r, op_tok_i)
			continue
		}

		if s_tok_kinds(tok_i) == tok_paren_l {
			op_tok_i = tok_i
			tok_i++

			negi_lang_parse_list tok_i, op_tok_i, exp_is, subexp_len

			if s_tok_kinds(tok_i) != tok_paren_r {
				exp_l = negi_lang_exp_add_err("丸カッコが閉じられていません。", op_tok_i)
				break
			}
			tok_i++

			exp_r = exp_l
			exp_l = negi_lang_exp_add_subexps(exp_call, exp_is, subexp_len, op_tok_i)
			s_exp_exp_ls(exp_l) = exp_r
			continue
		}

		break
	loop

	return exp_l

// 前置式をパースする。
// ここでは `-x` のように式の前に演算子がつく種類の式を前置式と呼んでいる。
#defcfunc negi_lang_parse_prefix var tok_i, \
	local exp_l, local exp_r, local op_tok_i, local op_text

	if s_tok_kinds(tok_i) == tok_op {
		op_tok_i = tok_i
		op_text = negi_lang_tok_text(tok_i)
		tok_i++

		if op_text == "-" {
			exp_l = negi_lang_exp_add_int(exp_int, 0, op_tok_i)
			exp_r = negi_lang_parse_suffix(tok_i)
			return negi_lang_exp_add_bin(op_sub, exp_l, exp_r, op_tok_i)
		}

		return negi_lang_exp_add_err("この演算子は前置演算子ではありません。", op_tok_i)
	}

	return negi_lang_parse_suffix(tok_i)

// トークンが演算子で、指定されたレベルを持つなら、その演算子の種類を返す。
// そうでなければ op_err を返す。
#defcfunc negi_lang_parse_op var tok_i, int op_level, \
	local op_text

	if s_tok_kinds(tok_i) != tok_op {
		return op_err
	}

	op_text = negi_lang_tok_text(tok_i)

	if op_level == op_level_set {
		if op_text == "=" { return op_set }
		if op_text == "+=" { return op_set_add }
		if op_text == "-=" { return op_set_sub }
		if op_text == "*=" { return op_set_mul }
		if op_text == "/=" { return op_set_div }
		if op_text == "%=" { return op_set_mod }
	}
	if op_level == op_level_cmp {
		if op_text == "==" {
			return op_eq
		}
		if op_text == "!=" {
			return op_ne
		}
		if op_text == "<" {
			return op_lt
		}
		if op_text == "<=" {
			return op_le
		}
		if op_text == ">" {
			return op_gt
		}
		if op_text == ">=" {
			return op_ge
		}
	}
	if op_level == op_level_add {
		if op_text == "+" {
			return op_add
		}
		if op_text == "-" {
			return op_sub
		}
	}
	if op_level == op_level_mul {
		if op_text == "*" {
			return op_mul
		}
		if op_text == "/" {
			return op_div
		}
		if op_text == "%" {
			return op_mod
		}
	}
	return op_err

// 指定されたレベルの演算子より一段階結合力が高い演算子の式をパースする。
#defcfunc negi_lang_parse_bin_next var tok_i, int op_level

	if op_level == op_level_mul {
		return negi_lang_parse_prefix(tok_i)
	}
	return negi_lang_parse_bin(tok_i, op_level + 1)

// 指定されたレベルの演算子からなる、2項演算子の式をパースする。
#defcfunc negi_lang_parse_bin var tok_i, int op_level, \
	local exp_l, local exp_r, local op_text, local op, local op_tok_i

	exp_l = negi_lang_parse_bin_next(tok_i, op_level)

	repeat
		if s_tok_kinds(tok_i) != tok_op {
			break
		}

		op_tok_i = tok_i
		op = negi_lang_parse_op(tok_i, op_level)
		if op == op_err {
			break
		}

		tok_i++
		exp_r = negi_lang_parse_bin_next(tok_i, op_level)
		exp_l = negi_lang_exp_add_bin(op, exp_l, exp_r, op_tok_i)
	loop
	return exp_l

// 代入式をパースする。
#defcfunc negi_lang_parse_set var tok_i, int op_level, \
	local exp_l, local exp_r, local op_text, local op, local op_tok_i

	exp_l = negi_lang_parse_bin(tok_i, op_level_cmp)

	if s_tok_kinds(tok_i) == tok_op {
		op_tok_i = tok_i
		op = negi_lang_parse_op(tok_i, op_level_set)
		if op != op_err {
			tok_i++
			exp_r = negi_lang_parse_term(tok_i)
			exp_l = negi_lang_exp_add_bin(op, exp_l, exp_r, op_tok_i)
		}
	}
	return exp_l

// 条件演算子の式をパースする
#defcfunc negi_lang_parse_cond var tok_i, \
	local cond_exp_i, local then_exp_i, local else_exp_i, local question_tok_i

	cond_exp_i = negi_lang_parse_set(tok_i)

	if (s_tok_kinds(tok_i) == tok_op && negi_lang_tok_text(tok_i) == "?") == false {
		return cond_exp_i
	}
	question_tok_i = tok_i
	tok_i++

	then_exp_i = negi_lang_parse_term(tok_i)

	if (s_tok_kinds(tok_i) == tok_op && negi_lang_tok_text(tok_i) == ":") == false {
		return negi_lang_exp_add_err("コロンが必要です。", question_tok_i)
	}
	tok_i++

	else_exp_i = negi_lang_parse_term(tok_i)

	return negi_lang_exp_add_if(cond_exp_i, then_exp_i, else_exp_i, question_tok_i)

#defcfunc negi_lang_parse_term var tok_i, \
	local kind

	kind = s_tok_kinds(tok_i)

	if kind == tok_eof {
		return negi_lang_exp_add_err("式が必要です。", tok_i)
	}
	if tok_leads_term(kind) == false {
		tok_i++
		return negi_lang_exp_add_err("式が必要です。", tok_i - 1)
	}
	if kind == tok_fun {
		return negi_lang_parse_fun(tok_i)
	}
	return negi_lang_parse_cond(tok_i)

#defcfunc negi_lang_parse_let var tok_i, \
	local let_tok_i, local ident_tok_i, local init_exp_i

	assert s_tok_kinds(tok_i) == tok_let
	let_tok_i = tok_i
	tok_i++

	if s_tok_kinds(tok_i) != tok_ident {
		return negi_lang_exp_add_err("変数名が必要です。", tok_i)
	}
	ident_tok_i = tok_i
	tok_i++

	if (s_tok_kinds(tok_i) == tok_op && negi_lang_tok_text(tok_i) == "=") == false {
		return negi_lang_exp_add_err("'=' が必要です。", tok_i)
	}
	tok_i++

	init_exp_i = negi_lang_parse_term(tok_i)

	return negi_lang_exp_add_let(ident_tok_i, init_exp_i, let_tok_i)

#defcfunc negi_lang_parse_stmt var tok_i

	assert tok_leads_stmt(s_tok_kinds(tok_i))

	if s_tok_kinds(tok_i) == tok_let {
		return negi_lang_parse_let(tok_i)
	}
	if s_tok_kinds(tok_i) == tok_if {
		return negi_lang_parse_if(tok_i)
	}
	if s_tok_kinds(tok_i) == tok_while {
		return negi_lang_parse_while(tok_i)
	}
	if s_tok_kinds(tok_i) == tok_break {
		return negi_lang_parse_break(tok_i)
	}
	if s_tok_kinds(tok_i) == tok_return {
		return negi_lang_parse_return(tok_i)
	}
	return negi_lang_parse_term(tok_i)

// セミコロン式をパースする。
// 末尾にあるセミコロンの後ろには 0 を補う。例えば `x;` は `x; 0` として扱う。
// 式がなければ 0 として扱う。
#defcfunc negi_lang_parse_semi var tok_i, \
	local kind, local exp_l, local exp_r, local semi_tok_i

	// セミコロンを読み飛ばす。
	repeat
		// ; nanika ---> nanika
		if s_tok_kinds(tok_i) != tok_semi { break }
		tok_i++
	loop

	kind = s_tok_kinds(tok_i)
	if tok_leads_stmt(kind) == false {
		return negi_lang_exp_add_int(exp_int, 0, semi_tok_i)
	}

	exp_l = negi_lang_parse_stmt(tok_i)

	repeat
		semi_tok_i = tok_i

		// セミコロンを読み飛ばす。
		repeat
			// ; nanika ---> nanika
			if s_tok_kinds(tok_i) != tok_semi { break }
			tok_i++
		loop

		kind = s_tok_kinds(tok_i)
		if tok_leads_stmt(kind) == false && semi_tok_i != tok_i {
			// nanika ; ---> nanika ; 0
			exp_r = negi_lang_exp_add_int(exp_int, 0, semi_tok_i)
			exp_l = negi_lang_exp_add_bin(op_semi, exp_l, exp_r)
			break
		}
		if tok_leads_stmt(kind) == false {
			break
		}

		exp_r = negi_lang_parse_stmt(tok_i)
		exp_l = negi_lang_exp_add_bin(op_semi, exp_l, exp_r)
	loop

	return exp_l

// 指定されたトークンで始まる式をパースする。
#defcfunc negi_lang_parse_exp var tok_i

	return negi_lang_parse_semi(tok_i)

// 構文解析を実行する。
#deffunc negi_lang_parse \
	local exp_i, local tok_i

	assert s_exp_len == 0

	// 特定の式を登録する。
	exp_i = negi_lang_exp_add_err("NOT AN EXPRESSION", 0)
	assert exp_i == exp_i_none

	tok_i = 0
	s_exp_i_root = negi_lang_parse_exp(tok_i)
	assert s_exp_i_root != exp_i_none

	if s_tok_kinds(tok_i) != tok_eof {
		d_trace "tok_i = " + tok_i + ", kind = " + s_tok_kinds(tok_i)
		negi_lang_err_add "この字句を解釈できませんでした。", s_tok_src_ls(tok_i), s_tok_src_rs(tok_i)
	}
	return

// ###############################################
// コード生成
// ###############################################

// 抽象構文木を辿って、中間言語の命令リストを生成する。
// 中間言語はよくあるスタックマシン。

// -----------------------------------------------
// ラベルリスト
// -----------------------------------------------

#deffunc negi_lang_label_initialize

	// ラベルのリスト
	// cmd_i: ラベルが指す命令列上の位置
	dim s_label_cmd_is
	s_label_len = 0
	return

#defcfunc negi_lang_label_add

	s_label_cmd_is(s_label_len) = -1
	s_label_len++
	return s_label_len - 1

#deffunc negi_lang_label_set int label_i, int cmd_i

	s_label_cmd_is(label_i) = cmd_i
	return

// -----------------------------------------------
// スコープリスト
// -----------------------------------------------

#deffunc negi_lang_scope_initialize

	// parent: 親スコープのスコープ番号 (トップレベルなら 0)
	// len: スコープに属する識別子の個数
	dim s_scope_parents
	dim s_scope_lens
	dim s_scope_tok_is
	s_scope_len = 1

	// スコープスタックの一番上のスコープ番号
	s_scope_current = scope_i_global

	s_scope_parents(scope_i_global) = -1
	return

#deffunc negi_lang_scope_push int tok_i

	s_scope_parents(s_scope_len) = s_scope_current
	s_scope_lens(s_scope_len) = 0
	s_scope_tok_is(s_scope_len) = tok_i
	s_scope_len++

	s_scope_current = s_scope_len - 1
	return

#deffunc negi_lang_scope_pop

	assert s_scope_current >= 1
	s_scope_current = s_scope_parents(s_scope_current)
	return

// -----------------------------------------------
// ローカルリスト
// -----------------------------------------------

// スコープに属する識別子からなるリスト。

#deffunc negi_lang_local_initialize

	// scope_is: 識別子が属するスコープ番号
	// indexes: 識別子がスコープにおいて何番目か
	// tok_i: 識別子が定義される箇所のトークン番号
	sdim s_local_idents
	dim s_local_scope_is
	dim s_local_indexes
	dim s_local_tok_is
	s_local_len = 0
	return

#defcfunc negi_lang_local_add_var str ident, int tok_i

	s_scope_lens(s_scope_current)++

	s_local_scope_is(s_local_len) = s_scope_current
	s_local_indexes(s_local_len) = s_scope_lens(s_scope_current) - 1
	s_local_idents(s_local_len) = ident
	s_local_tok_is(s_local_len) = tok_i
	s_local_len++
	return s_local_len - 1

#deffunc negi_lang_local_find_var str ident, var out_index, \
	local scope_i

	out_index = -1
	scope_i = s_scope_current
	repeat
		repeat s_local_len
			if s_local_scope_is(cnt) != scope_i { continue }
			if s_local_idents(cnt) != ident { continue }
			out_index = cnt
			break
		loop

		if s_scope_parents(scope_i) < 0 { break }
		assert scope_i != s_scope_parents(scope_i)
		scope_i = s_scope_parents(scope_i)
	loop
	return

// -----------------------------------------------
// 関数リスト
// -----------------------------------------------

#deffunc negi_lang_fun_initialize

	// 関数のリスト
	// kind: 関数の種類
	// name: 関数の名前
	// scope_i: 関数本体が属するスコープ (クロージャのみ)
	// label_i: 関数本体のラベル番号 (クロージャのみ)
	dim s_fun_kinds
	sdim s_fun_names
	dim s_fun_scope_is
	dim s_fun_label_is
	s_fun_len = 0
	return

#defcfunc negi_lang_fun_add_closure int scope_i, int body_label_i

	s_fun_kinds(s_fun_len) = fun_kind_closure
	s_fun_names(s_fun_len) = "<anonymous: " + body_label_i + ">"
	s_fun_scope_is(s_fun_len) = scope_i
	s_fun_label_is(s_fun_len) = body_label_i
	s_fun_len++
	return s_fun_len - 1

// -----------------------------------------------
// ループスタック
// -----------------------------------------------

#deffunc negi_lang_loop_initialize

	// ループスタック
	// break/continue のジャンプ先を決定するために使う。
	// break: break のジャンプ先のラベル番号
	dim s_loop_breaks
	s_loop_len = 0
	return

#deffunc negi_lang_loop_push int break_label_i

	s_loop_breaks(s_loop_len) = break_label_i
	s_loop_len++
	return

#deffunc negi_lang_loop_pop

	assert s_loop_len >= 1
	s_loop_len--
	return

// -----------------------------------------------
// 命令リスト
// -----------------------------------------------

#deffunc negi_lang_cmd_initialize

	// kind: 命令の種類
	// x, y: 命令がとる整数型の引数
	// str: 命令がとる文字列型の引数
	// tok_i: 命令に関連するトークン番号
	dim s_cmd_kinds
	dim s_cmd_xs
	dim s_cmd_ys
	sdim s_cmd_strs
	dim s_cmd_tok_is
	s_cmd_len = 0
	return

// 命令を追加する。
// tok_i: この命令と関連するトークン番号
#deffunc negi_lang_cmd_add int kind, int tok_i

	s_cmd_kinds(s_cmd_len) = kind
	s_cmd_xs(s_cmd_len) = 0
	s_cmd_ys(s_cmd_len) = 0
	s_cmd_strs(s_cmd_len) = ""
	s_cmd_tok_is(s_cmd_len) = tok_i
	s_cmd_len++
	return

// エラーを報告する命令を追加する。
#deffunc negi_lang_cmd_add_err str message, int tok_i

	negi_lang_cmd_add cmd_err, tok_i
	s_cmd_strs(s_cmd_len - 1) = message
	return

// 整数値を引数に持つ命令を追加する。
#deffunc negi_lang_cmd_add_int int kind, int value, int tok_i

	negi_lang_cmd_add kind, tok_i
	s_cmd_xs(s_cmd_len - 1) = value
	return

// 文字列を引数に持つ命令を追加する。
#deffunc negi_lang_cmd_add_str int kind, str value, int tok_i

	negi_lang_cmd_add kind, tok_i
	s_cmd_strs(s_cmd_len - 1) = value
	return

#deffunc negi_lang_cmd_add_local_var int index, int scope_i, int tok_i

	negi_lang_cmd_add_int cmd_local_var, index, tok_i
	s_cmd_ys(s_cmd_len - 1) = scope_i
	return

// 否定演算の命令を追加する。 (!x ---> x == false)
#deffunc negi_lang_cmd_add_negate int tok_i

	negi_lang_cmd_add_int cmd_push_int, false, tok_i
	negi_lang_cmd_add_int cmd_op, op_eq, tok_i
	return

#deffunc negi_lang_cmd_add_goto int label_i, int tok_i

	negi_lang_cmd_add_int cmd_push_int, false, tok_i
	negi_lang_cmd_add_int cmd_jump_unless, label_i, tok_i
	return

// -----------------------------------------------
// コード生成
// -----------------------------------------------

#deffunc negi_lang_gen_exp_ident int exp_i, int lval, \
	local name, local tok_i, local local_i, local scope_i, local extern_fun_i

	assert s_exp_kinds(exp_i) == exp_ident
	name = s_exp_strs(exp_i)
	tok_i = s_exp_tok_is(exp_i)

	negi_lang_local_find_var name, local_i
	if local_i >= 0 {
		scope_i = s_local_scope_is(local_i)
		negi_lang_cmd_add_local_var s_local_indexes(local_i), scope_i, tok_i
		if lval == false {
			negi_lang_cmd_add cmd_cell_get, tok_i
		}
		return
	}

	if lval == false {
		extern_fun_i = negi_lang_extern_fun_find(name)
		if extern_fun_i >= 0 {
			negi_lang_cmd_add_int cmd_push_extern, extern_fun_i, tok_i
			return
		}
	}

	negi_lang_cmd_add_err "未定義の変数を使用しています。", s_exp_tok_is(exp_i)
	return

#deffunc negi_lang_gen_exp_array int exp_i, \
	local subexp_l, local subexp_r, local exp_l, local exp_r, local len, local tok_i

	assert s_exp_kinds(exp_i) == exp_array
	subexp_l = s_exp_subexp_ls(exp_i)
	subexp_r = s_exp_subexp_rs(exp_i)
	len = subexp_r - subexp_l
	tok_i = s_exp_tok_is(exp_i)

	negi_lang_cmd_add_int cmd_push_array, len, tok_i
	repeat len
		negi_lang_gen_exp s_subexp_exp_is(subexp_l + cnt)
		negi_lang_cmd_add_int cmd_op, op_array_push, tok_i
	loop
	return

#deffunc negi_lang_gen_exp_call int exp_i, \
	local subexp_l, local subexp_r, local len, local tok_i

	assert s_exp_kinds(exp_i) == exp_call
	subexp_l = s_exp_subexp_ls(exp_i)
	subexp_r = s_exp_subexp_rs(exp_i)
	len = subexp_r - subexp_l
	tok_i = s_exp_tok_is(exp_i)

	negi_lang_gen_exp s_exp_exp_ls(exp_i)
	repeat len
		negi_lang_gen_exp s_subexp_exp_is(subexp_l + cnt)
	loop
	negi_lang_cmd_add_int cmd_call, len, tok_i
	return

#deffunc negi_lang_gen_exp_if int exp_i, \
	local cond_exp_i, local then_exp_i, local else_exp_i, \
	local else_label_i, local end_label_i, local tok_i

	assert s_exp_kinds(exp_i) == exp_if
	cond_exp_i = s_exp_exp_conds(exp_i)
	then_exp_i = s_exp_exp_ls(exp_i)
	else_exp_i = s_exp_exp_rs(exp_i)
	tok_i = s_exp_tok_is(exp_i)

	else_label_i = negi_lang_label_add()
	end_label_i = negi_lang_label_add()

	// if cond == false : goto *l_else
	negi_lang_gen_exp cond_exp_i
	negi_lang_cmd_add_int cmd_jump_unless, else_label_i, tok_i

	// do `then` : goto *l_end
	negi_lang_gen_exp then_exp_i
	negi_lang_cmd_add_goto end_label_i, tok_i

	// *l_else: do `else`
	negi_lang_cmd_add_int cmd_label, else_label_i, tok_i
	negi_lang_gen_exp else_exp_i

	// *l_end
	negi_lang_cmd_add_int cmd_label, end_label_i, tok_i
	return

// while 文のコードを生成する。
// スタックに何らかの値をちょうど1つ積んだ状態で終了するように気をつける。
#deffunc negi_lang_gen_exp_while int exp_i, \
	local cond_exp_i, local body_exp_i, \
	local begin_label_i, local else_label_i, local tok_i

	assert s_exp_kinds(exp_i) == exp_while
	cond_exp_i = s_exp_exp_conds(exp_i)
	body_exp_i = s_exp_exp_ls(exp_i)
	tok_i = s_exp_tok_is(exp_i)
	assert cond_exp_i != exp_i_none
	assert body_exp_i != exp_i_none

	begin_label_i = negi_lang_label_add()
	else_label_i = negi_lang_label_add()

	negi_lang_loop_push else_label_i

	// *l_begin : if cond == false : goto *l_else
	negi_lang_cmd_add_int cmd_label, begin_label_i, tok_i

	negi_lang_gen_exp cond_exp_i
	negi_lang_cmd_add_int cmd_jump_unless, else_label_i, tok_i

	// do `then` : pop : goto *l_begin
	negi_lang_gen_exp body_exp_i
	negi_lang_cmd_add cmd_pop, tok_i

	negi_lang_cmd_add_goto begin_label_i, tok_i

	// *l_else : do `else`
	negi_lang_cmd_add_int cmd_label, else_label_i, tok_i
	negi_lang_cmd_add_int cmd_push_int, 0, tok_i

	negi_lang_loop_pop
	return

#deffunc negi_lang_gen_exp_break int exp_i, \
	local break_label_i, local tok_i

	assert s_exp_kinds(exp_i) == exp_break
	tok_i = s_exp_tok_is(exp_i)

	if s_loop_len == 0 {
		negi_lang_cmd_add_err "ループの外側では break を使用できません。", tok_i
		return
	}
	break_label_i = s_loop_breaks(s_loop_len - 1)

	negi_lang_cmd_add_goto break_label_i, tok_i
	return

// 2項演算を行うコードを生成する。
// 評価の実装を簡単にするため、式を適当に変形する。
#deffunc negi_lang_gen_exp_op int exp_i, int lval, \
	local op

	assert s_exp_kinds(exp_i) == exp_op
	op = s_exp_ints(exp_i)

	if op == op_semi {
		negi_lang_gen_exp s_exp_exp_ls(exp_i)
		negi_lang_cmd_add cmd_pop, s_exp_tok_is(exp_i)
		negi_lang_gen_exp s_exp_exp_rs(exp_i)
		return
	}
	if op == op_set {
		negi_lang_gen_exp_set exp_i
		return
	}
	if op == op_set_add || op == op_set_sub || op == op_set_mul || op == op_set_div || op == op_set_mod {
		negi_lang_gen_exp_set_op exp_i
		return
	}

	negi_lang_gen_exp s_exp_exp_ls(exp_i)
	negi_lang_gen_exp s_exp_exp_rs(exp_i)

	if op == op_ne {
		// l != r ---> !(l == r)
		negi_lang_cmd_add_int cmd_op, op_eq, s_exp_tok_is(exp_i)
		negi_lang_cmd_add_negate s_exp_tok_is(exp_i)
		return
	}
	if op == op_le {
		// l <= r ---> !(r < l)
		negi_lang_cmd_add cmd_swap, s_exp_tok_is(exp_i)
		negi_lang_cmd_add_int cmd_op, op_lt, s_exp_tok_is(exp_i)
		negi_lang_cmd_add_negate s_exp_tok_is(exp_i)
		return
	}
	if op == op_gt {
		// l > r ---> r < l
		negi_lang_cmd_add cmd_swap, s_exp_tok_is(exp_i)
		negi_lang_cmd_add_int cmd_op, op_lt, s_exp_tok_is(exp_i)
		return
	}
	if op == op_ge {
		// l >= r ---> !(l < r)
		negi_lang_cmd_add_int cmd_op, op_lt, s_exp_tok_is(exp_i)
		negi_lang_cmd_add_negate s_exp_tok_is(exp_i)
		return
	}
	if op == op_index && lval {
		negi_lang_cmd_add_int cmd_op, op_index_ref, s_exp_tok_is(exp_i)
		return
	}

	negi_lang_cmd_add_int cmd_op, op, s_exp_tok_is(exp_i)

	return

#deffunc negi_lang_gen_exp_set int exp_i

	assert s_exp_kinds(exp_i) == exp_op && s_exp_ints(exp_i) == op_set

	negi_lang_gen_lval s_exp_exp_ls(exp_i)
	negi_lang_gen_exp s_exp_exp_rs(exp_i)
	negi_lang_cmd_add cmd_cell_set, s_exp_tok_is(exp_i)
	return

#deffunc negi_lang_gen_exp_set_op int exp_i, \
	local tok_i, local set_op, local op

	assert s_exp_kinds(exp_i) == exp_op
	set_op = s_exp_ints(exp_i)
	tok_i = s_exp_tok_is(exp_i)

	op = op_err
	if set_op == op_set_add { op = op_add }
	if set_op == op_set_sub { op = op_sub }
	if set_op == op_set_mul { op = op_mul }
	if set_op == op_set_div { op = op_div }
	if set_op == op_set_mod { op = op_mod }
	assert op != op_err

	// 左辺を計算して参照セルを得る。
	negi_lang_gen_lval s_exp_exp_ls(exp_i)

	// この参照セルは2回使うので複製する。2つ目は値に変換する。
	negi_lang_cmd_add cmd_dup, tok_i
	negi_lang_cmd_add cmd_cell_get, tok_i

	// 右辺を計算して演算する。
	negi_lang_gen_exp s_exp_exp_rs(exp_i)
	negi_lang_cmd_add_int cmd_op, op, tok_i

	// 参照セルに演算結果を代入する。
	negi_lang_cmd_add cmd_cell_set, tok_i
	return

#deffunc negi_lang_gen_exp_let int exp_i, \
	local ident_tok_i, local ident, local local_i

	assert s_exp_kinds(exp_i) == exp_let
	ident_tok_i = s_exp_ints(exp_i)
	ident = negi_lang_tok_text(ident_tok_i)

	negi_lang_gen_exp s_exp_exp_rs(exp_i)

	local_i = negi_lang_local_add_var(ident, ident_tok_i)
	negi_lang_cmd_add_local_var s_local_indexes(local_i), s_local_scope_is(local_i), ident_tok_i
	negi_lang_cmd_add cmd_swap, s_exp_tok_is(exp_i)
	negi_lang_cmd_add cmd_cell_set, s_exp_tok_is(exp_i)
	return

#deffunc negi_lang_gen_exp_fun int exp_i, \
	local subexp_l, local subexp_r, local body_exp_i, local tok_i, \
	local scope_i, local index, local param_exp_i, \
	local body_label_i, local return_label_i, local next_label_i, local fun_i

	assert s_exp_kinds(exp_i) == exp_fun
	body_exp_i = s_exp_exp_ls(exp_i)
	subexp_l = s_exp_subexp_ls(exp_i)
	subexp_r = s_exp_subexp_rs(exp_i)
	tok_i = s_exp_tok_is(exp_i)

	body_label_i = negi_lang_label_add()
	next_label_i = negi_lang_label_add()

	// 関数本体が実行されないようにスキップする。
	negi_lang_cmd_add_goto next_label_i, tok_i

	// 関数の入り口
	negi_lang_cmd_add_int cmd_label, body_label_i, tok_i

	negi_lang_scope_push tok_i
	scope_i = s_scope_current

	// 仮引数リストを解析する
	repeat subexp_r - subexp_l, subexp_l
		param_exp_i = s_subexp_exp_is(cnt)
		index = cnt - subexp_l

		if s_exp_kinds(param_exp_i) != exp_ident {
			negi_lang_cmd_add_err "仮引数は識別子でなければいけません。", s_exp_tok_is(param_exp_i)
			continue
		}

		_ = negi_lang_local_add_var(s_exp_strs(param_exp_i), s_exp_tok_is(param_exp_i))
	loop

	// 関数本体を解析する。
	// FIXME: break が関数の外側のループに飛ばないようにする。

	// return `body`
	negi_lang_gen_exp body_exp_i
	negi_lang_cmd_add cmd_return, tok_i

	negi_lang_scope_pop
	fun_i = negi_lang_fun_add_closure(scope_i, body_label_i)

	// 関数を生成する。
	negi_lang_cmd_add_int cmd_label, next_label_i, tok_i
	negi_lang_cmd_add_int cmd_push_closure, fun_i, tok_i

	return

#deffunc negi_lang_gen_exp_return int exp_i, \
	local exp_l, local tok_i

	assert s_exp_kinds(exp_i) == exp_return
	exp_l = s_exp_exp_ls(exp_i)
	tok_i = s_exp_tok_is(exp_i)

	negi_lang_gen_exp exp_l
	negi_lang_cmd_add cmd_return, tok_i
	return

// 式を計算して左辺値をスタックに積むコードを生成する。
#deffunc negi_lang_gen_lval int exp_i, \
	local lval

	lval = true

	if s_exp_kinds(exp_i) == exp_ident {
		negi_lang_gen_exp_ident exp_i, lval
		return
	}
	if s_exp_kinds(exp_i) == exp_op && s_exp_ints(exp_i) == op_index {
		negi_lang_gen_exp_op exp_i, lval
		return
	}

	negi_lang_cmd_add_err "左辺値が必要です。", s_exp_tok_is(exp_i)
	return

// 式を計算するコードを生成する。
#deffunc negi_lang_gen_exp int exp_i

	if s_exp_kinds(exp_i) == exp_int {
		negi_lang_cmd_add_int cmd_push_int, s_exp_ints(exp_i), s_exp_tok_is(exp_i)
		return
	}
	if s_exp_kinds(exp_i) == exp_str {
		negi_lang_cmd_add_str cmd_push_str, s_exp_strs(exp_i), s_exp_tok_is(exp_i)
		return
	}
	if s_exp_kinds(exp_i) == exp_array {
		negi_lang_gen_exp_array exp_i
		return
	}
	if s_exp_kinds(exp_i) == exp_ident {
		negi_lang_gen_exp_ident exp_i
		return
	}
	if s_exp_kinds(exp_i) == exp_call {
		negi_lang_gen_exp_call exp_i
		return
	}
	if s_exp_kinds(exp_i) == exp_op {
		negi_lang_gen_exp_op exp_i, false
		return
	}
	if s_exp_kinds(exp_i) == exp_let {
		negi_lang_gen_exp_let exp_i
		return
	}
	if s_exp_kinds(exp_i) == exp_if {
		negi_lang_gen_exp_if exp_i
		return
	}
	if s_exp_kinds(exp_i) == exp_while {
		negi_lang_gen_exp_while exp_i
		return
	}
	if s_exp_kinds(exp_i) == exp_break {
		negi_lang_gen_exp_break exp_i
		return
	}
	if s_exp_kinds(exp_i) == exp_fun {
		negi_lang_gen_exp_fun exp_i
		return
	}
	if s_exp_kinds(exp_i) == exp_return {
		negi_lang_gen_exp_return exp_i
		return
	}
	if s_exp_kinds(exp_i) == exp_err {
		negi_lang_cmd_add_str cmd_err, s_exp_strs(exp_i), s_exp_tok_is(exp_i)
		return
	}
	d_trace "kind = " + s_exp_kinds(exp_i)
	failwith "unknown expression kind"

// コード生成を実行する。
#deffunc negi_lang_gen \
	local main_label_i

	assert s_exp_i_root != exp_i_none

	// 先頭にラベルを置く。
	main_label_i = negi_lang_label_add()
	negi_lang_cmd_add_int cmd_label, main_label_i, 0

	// コード生成。
	negi_lang_gen_exp s_exp_i_root

	// スタックにある値を終了コードとして終了する命令を末尾に追加する。
	negi_lang_cmd_add cmd_exit, s_tok_len - 1

	// トップレベルに対応する関数を登録する。
	s_fun_i_main = negi_lang_fun_add_closure(scope_i_global, main_label_i)

	// ラベルを解決する。
	repeat s_cmd_len
		if s_cmd_kinds(cnt) == cmd_label {
			negi_lang_label_set s_cmd_xs(cnt), cnt
		}
	loop
	return

// ###############################################
// 評価
// ###############################################

// 中間言語のコードを実行して、実際に計算を行う。

// -----------------------------------------------
// 参照セルリスト
// -----------------------------------------------

// 変数や配列要素などのデータを配置する領域。メモリ空間のようなもの。

#deffunc negi_lang_cell_initialize

	// ty, val: セルの型タグと値
	// stack_ptr: いまのスタックの末尾
	// stack_ptr_max: スタック全体の末尾 (= ヒープの先頭)
	// heap_ptr: いまのヒープの末尾
	s_cell_len = cell_len_min
	dim s_cell_tys, s_cell_len
	dim s_cell_vals, s_cell_len
	s_cell_i_stack_end = 0
	s_cell_i_heap_end = stack_len_min

	// ヒープ領域の残りの個数がこの値を下回ったら GC する。
	s_gc_threshold = 1024
	return

#deffunc negi_lang_cell_gc_begin

	// README に書いてある通り、gc_map はGC段階によって異なる意味を持つ。
	// mark フェイズでは、true ならセルがマーク済みであることを表す。
	// 		gc_map(cell_i) = true
	// move フェイズでは、セルの移動先の位置を表す。セルが破棄された場合は -1
	// 		gc_map(old_i) = new_i
	dim s_cell_gc_map, s_cell_len
	s_cell_gc_map_len = 0

	// スタック。マーク済みの参照セルで、まだ値にマークする処理が済んでいないものを積んでいく。
	dim s_cell_gc_stack
	s_cell_gc_stack_len = 0
	return

#deffunc negi_lang_cell_gc_mark int cell_i

	if s_cell_gc_map(cell_i) { return }

	s_cell_gc_map(cell_i) = true
	s_cell_gc_stack(s_cell_gc_stack_len) = cell_i
	s_cell_gc_stack_len++
	return

#deffunc negi_lang_cell_gc_mark_loop var stuck, \
	local cell_i, local ty, local val

	repeat
		if s_cell_gc_stack_len == 0 { break }

		stuck = false
		s_cell_gc_stack_len--
		cell_i = s_cell_gc_stack(s_cell_gc_stack_len)

		ty = s_cell_tys(cell_i)
		val = s_cell_vals(cell_i)

		if ty == ty_array {
			negi_lang_array_gc_mark val
		}
	loop
	return

#deffunc negi_lang_cell_gc_mark_stack

	repeat s_cell_i_stack_end
		negi_lang_cell_gc_mark cnt
	loop
	return

#deffunc negi_lang_cell_gc_move \
	local cell_i

	repeat s_cell_len
		// スタック領域は移動しない。
		if cnt < s_cell_i_stack_max {
			s_cell_gc_map(cnt) = cnt
			s_cell_gc_map_len++
			continue
		}
		if s_cell_gc_map(cnt) == false {
			s_cell_gc_map(cnt) = -1
			continue
		}

		cell_i = s_cell_gc_map_len
		s_cell_gc_map(cnt) = cell_i
		s_cell_gc_map_len++

		s_cell_tys(cell_i) = s_cell_tys(cnt)
		s_cell_vals(cell_i) = s_cell_vals(cnt)
	loop

	assert s_cell_gc_map_len >= stack_len_min
	d_trace "GC " + (s_cell_i_heap_end - s_cell_gc_map_len) + " 個のセルを解放"
	s_cell_i_heap_end = s_cell_gc_map_len
	return

#deffunc negi_lang_cell_gc_rewrite_all

	declare { dim s_array_gc_map }

	repeat s_cell_i_heap_end
		if s_cell_i_stack_end <= cnt && cnt < stack_len_min { continue }

		if s_cell_tys(cnt) == ty_array {
			s_cell_vals(cnt) = s_array_gc_map(s_cell_vals(cnt))
		}
	loop
	return

// -----------------------------------------------
// スタック
// -----------------------------------------------

// スタックに値を積む。
#deffunc negi_lang_stack_push int ty, int val

	d_trace "push ty=" + ty + " val=" + val

	if s_cell_i_stack_end >= s_cell_i_stack_max {
		// FIXME: エラー箇所を報告する
		negi_lang_eval_abort "STACK OVERFLOW", 0
		return
	}

	s_cell_tys(s_cell_i_stack_end) = ty
	s_cell_vals(s_cell_i_stack_end) = val
	s_cell_i_stack_end++
	return

// スタックから値を取り出す。
#deffunc negi_lang_stack_pop var out_ty, var out_val

	assert s_cell_i_stack_end >= 1
	s_cell_i_stack_end--
	out_ty = s_cell_tys(s_cell_i_stack_end)
	out_val = s_cell_vals(s_cell_i_stack_end)

	d_trace "pop ty=" + out_ty + " val=" + out_val
	return

// -----------------------------------------------
// ヒープ
// -----------------------------------------------

#deffunc negi_lang_heap_alloc int count, var out_cell_l, var out_cell_r

	if s_cell_i_heap_end + count > s_cell_len {
		// FIXME: ヒープを自動で拡張する
		negi_lang_eval_abort "OUT OF MEMORY", 0
		return
	}

	out_cell_l = s_cell_i_heap_end
	out_cell_r = s_cell_i_heap_end + count
	s_cell_i_heap_end += count

	if s_cell_len - s_cell_i_heap_end <= s_gc_threshold {
		s_gc_force = true
	}
	return

// -----------------------------------------------
// フレームスタック
// -----------------------------------------------

// 関数呼び出しのメタ情報からなるスタック。

#deffunc negi_lang_frame_initialize

	// cmd_i: return 直後に実行するコマンド番号
	// env_i: 実行中の環境番号
	// tok_i: フレームに関係のあるトークン番号
	dim s_frame_cmd_is, 16
	dim s_frame_env_is, 16
	dim s_frame_tok_is, 16
	s_frame_len = 0
	return

#deffunc negi_lang_frame_gc_mark_all

	repeat s_frame_len
		negi_lang_env_gc_mark s_frame_env_is(cnt)
	loop
	return

#deffunc negi_lang_frame_push int cmd_i, int env_i, int tok_i, \
	local frame_i

	frame_i = s_frame_len
	if frame_i == length(s_frame_tok_is) {
		s_frame_len *= 2
		negi_lang_frame_push cmd_i, env_i, tok_i
	}
	s_frame_len = frame_i + 1

	s_frame_cmd_is(frame_i) = cmd_i
	s_frame_env_is(frame_i) = env_i
	s_frame_tok_is(frame_i) = tok_i
	return

#defcfunc negi_lang_frame_pop

	assert s_frame_len >= 1
	s_frame_len--
	return s_frame_cmd_is(s_frame_len)

// -----------------------------------------------
// 文字列リスト
// -----------------------------------------------

#deffunc negi_lang_str_initialize

	sdim s_strs, 16, 1024
	s_str_len = 0
	return

// 文字列リストに追加して、その番号を返す。
#defcfunc negi_lang_str_add str value

	s_strs(s_str_len) = value
	s_str_len++
	return s_str_len - 1

// -----------------------------------------------
// 配列リスト
// -----------------------------------------------

#deffunc negi_lang_array_initialize

	// len: 配列の現在の長さ
	// cell_l, cell_r: この配列の要素が占めるセルリストの範囲
	dim s_array_lens, 16
	dim s_array_cell_ls, 16
	dim s_array_cell_rs, 16
	s_array_len = 0
	return

#deffunc negi_lang_array_gc_begin

	dim s_array_gc_map, s_array_len
	s_array_gc_map_len = 0

	dim s_array_gc_stack
	s_array_gc_stack_len = 0
	return

#deffunc negi_lang_array_gc_mark int array_i

	if s_array_gc_map(array_i) { return }

	s_array_gc_map(array_i) = true
	s_array_gc_stack(s_array_gc_stack_len) = array_i
	s_array_gc_stack_len++
	return

#deffunc negi_lang_array_gc_mark_loop var stuck, \
	local array_i

	repeat
		if s_array_gc_stack_len == 0 { break }

		stuck = false
		s_array_gc_stack_len--
		array_i = s_array_gc_stack(s_array_gc_stack_len)

		repeat s_array_lens(array_i), s_array_cell_ls(array_i)
			negi_lang_cell_gc_mark cnt
		loop
	loop
	return

#deffunc negi_lang_array_gc_move \
	local array_i

	repeat s_array_len
		if s_array_gc_map(cnt) == false {
			s_array_gc_map(cnt) = -1
			continue
		}

		array_i = s_array_gc_map_len
		s_array_gc_map(cnt) = array_i
		s_array_gc_map_len++

		s_array_lens(array_i) = s_array_lens(cnt)
		s_array_cell_ls(array_i) = s_array_cell_ls(cnt)
		s_array_cell_rs(array_i) = s_array_cell_rs(cnt)
	loop

	s_array_len = s_array_gc_map_len
	return

#deffunc negi_lang_array_gc_rewrite_all \
	local capacity

	repeat s_array_len
		capacity = s_array_cell_rs(cnt) - s_array_cell_ls(cnt)
		if capacity == 0 { continue }

		// 長さが空なら cell_l のマップ先が存在しないので、領域を再確保する。
		if s_array_lens(cnt) == 0 {
			assert s_cell_gc_map(s_array_cell_ls(cnt)) < 0
			negi_lang_array_reserve ty_array, cnt, capacity
			continue
		}

		s_array_cell_ls(cnt) = s_cell_gc_map(s_array_cell_ls(cnt))
		s_array_cell_rs(cnt) = s_array_cell_ls(cnt) + capacity
	loop
	return

// 配列リストに新しい配列を追加して、その番号を返す。
// capacity: この配列の長さの最大値
#defcfunc negi_lang_array_add int len, int capacity, \
	local cell_l, local cell_r, local array_i

	assert 0 <= len && len <= capacity

	array_i = s_array_len
	if s_array_len == length(s_array_lens) {
		s_array_len *= 2
		_ = negi_lang_array_add(0, 0)
	}
	s_array_len = array_i + 1

	negi_lang_heap_alloc capacity, cell_l, cell_r

	s_array_lens(array_i) = len
	s_array_cell_ls(array_i) = cell_l
	s_array_cell_rs(array_i) = cell_r
	s_array_len++
	return array_i

// 配列のキャパシティを new_len 以上にする。
// 現在のキャパシティでは足りなければ、新しい領域を確保して移動する。
#deffunc negi_lang_array_reserve \
	int array_ty, int array_i, int new_len, \
	local current_len, local current_cell_l, local current_cell_r, \
	local new_capacity, local new_cell_l, local new_cell_r

	current_cell_l = s_array_cell_ls(array_i)
	current_cell_r = s_array_cell_rs(array_i)

	if new_len <= current_cell_r - current_cell_l {
		return
	}

	assert s_array_lens(array_i) <= new_len

	new_capacity = new_len + (new_len / 2)
	negi_lang_heap_alloc new_capacity, new_cell_l, new_cell_r

	s_array_cell_ls(array_i) = new_cell_l
	s_array_cell_rs(array_i) = new_cell_r

	repeat s_array_lens(array_i)
		s_cell_tys(new_cell_l + cnt) = s_cell_tys(current_cell_l + cnt)
		s_cell_vals(new_cell_l + cnt) = s_cell_vals(current_cell_l + cnt)
	loop
	return

// 配列の末尾に要素を追加する。
#deffunc negi_lang_array_push \
	int array_ty, int array_i, int elem_ty, int elem_val, \
	local index

	assert array_ty == ty_array
	index = s_array_lens(array_i)

	negi_lang_array_reserve array_ty, array_i, index + 1

	s_array_lens(array_i)++
	negi_lang_array_set array_ty, array_i, index, elem_ty, elem_val
	return

// 配列の index 番目の要素の参照セルを取得する。
#defcfunc negi_lang_array_ref int array_ty, int array_i, int index

	assert array_ty == ty_array
	assert 0 <= array_i && array_i < s_array_len

	if (0 <= index && index < s_array_lens(array_i)) == false {
		negi_lang_eval_abort "配列の要素番号が不正です。", 0 // FIXME: 位置情報
		return 0
	}

	return s_array_cell_ls(array_i) + index

// 配列の index 番目の要素を取得する。
#deffunc negi_lang_array_get \
	int array_ty, int array_i, int index, var out_ty, var out_val, \
	local cell_i

	cell_i = negi_lang_array_ref(array_ty, array_i, index)
	out_ty = s_cell_tys(cell_i)
	out_val = s_cell_vals(cell_i)
	return

// 配列の index 番目の要素を設定する。
#deffunc negi_lang_array_set \
	int array_ty, int array_i, int index, int item_ty, int item_val, \
	local cell_i

	cell_i = negi_lang_array_ref(array_ty, array_i, index)
	if (0 <= cell_i && cell_i < length(s_cell_tys)) == false {
		debug array_i
		debug index
		debug cell_i
	}
	s_cell_tys(cell_i) = item_ty
	s_cell_vals(cell_i) = item_val
	return

// -----------------------------------------------
// 環境リスト
// -----------------------------------------------

#deffunc negi_lang_env_initialize

	// parent: この環境の親となる環境番号 (なければ 0)
	// scope_i: この環境に対応するスコープ番号
	// array_is: 引数やローカル変数を格納する配列番号
	dim s_env_parents
	dim s_env_scope_is
	dim s_env_array_is
	s_env_len = 0

	// グローバル環境
	s_env_i_global = -1
	return

#deffunc negi_lang_env_gc_begin
	return

#deffunc negi_lang_env_gc_mark int env_i

	negi_lang_array_gc_mark s_env_array_is(env_i)
	return

#deffunc negi_lang_env_gc_mark_all

	repeat s_env_len
		negi_lang_env_gc_mark cnt
	loop
	return

#deffunc negi_lang_env_gc_rewrite_all

	repeat s_env_len
		s_env_array_is(cnt) = s_array_gc_map(s_env_array_is(cnt))
	loop
	return

#defcfunc negi_lang_env_add int parent_env_i, int fun_i, \
	local array_i, local array_len, local scope_i, local env_i

	env_i = s_env_len
	if s_env_len == length(s_env_parents) {
		s_env_len *= 2
		_ = negi_lang_env_add(parent_env_i, fun_i)
	}
	s_env_len = env_i + 1

	scope_i = s_fun_scope_is(fun_i)
	array_len = s_scope_lens(scope_i)
	array_i = negi_lang_array_add(array_len, array_len)

	s_env_parents(env_i) = parent_env_i
	s_env_scope_is(env_i) = scope_i
	s_env_array_is(env_i) = array_i
	return env_i

#defcfunc negi_lang_env_ref int source_env_i, int index, int scope_i, \
	local array_i, local env_i

	env_i = source_env_i
	repeat
		assert 0 <= env_i && env_i < s_env_len
		if s_env_scope_is(env_i) == scope_i { break }

		assert env_i != s_env_parents(env_i)
		env_i = s_env_parents(env_i)
	loop

	array_i = s_env_array_is(env_i)
	return negi_lang_array_ref(ty_array, array_i, index)

// -----------------------------------------------
// クロージャリスト
// -----------------------------------------------

#deffunc negi_lang_closure_initialize

	// fun_i: このクロージャに対応する関数番号
	// env_i: このクロージャが生成された環境番号
	dim s_closure_fun_is
	dim s_closure_env_is
	s_closure_len = 0
	return

#defcfunc negi_lang_closure_add int fun_i, int env_i

	assert s_fun_kinds(fun_i) == fun_kind_closure

	s_closure_fun_is(s_closure_len) = fun_i
	s_closure_env_is(s_closure_len) = env_i
	s_closure_len++
	return s_closure_len - 1

// -----------------------------------------------
// 外部関数リスト
// -----------------------------------------------

#deffunc negi_lang_extern_fun_initialize

	// label: 関数が呼ばれたときに実行される HSP のラベル
	dim s_extern_fun_names, 256
	ldim s_extern_fun_labels, 256
	s_extern_fun_len = 0

	negi_lang_extern_fun_builtin
	return

#deffunc negi_lang_extern_fun_add str name, label label

	s_extern_fun_names(s_extern_fun_len) = name
	s_extern_fun_labels(s_extern_fun_len) = label
	s_extern_fun_len++
	return

#defcfunc negi_lang_extern_fun_find str name, \
	local extern_fun_i

	extern_fun_i = -1
	repeat s_extern_fun_len
		if s_extern_fun_names(cnt) == name {
			extern_fun_i = cnt
		}
	loop
	return extern_fun_i

// -----------------------------------------------
// 外部関数フレーム
// -----------------------------------------------

// 外部関数の呼び出しのメタ情報を格納する。

#deffunc negi_lang_extern_frame_initialize

	// array_i: 引数リストである配列番号
	// result: 結果を格納するセル番号
	// err: エラーが発生したかどうかを表す
	s_extern_frame_array_i = -1
	s_extern_frame_result = -1
	s_extern_frame_err = false
	s_extern_frame_err_message = ""
	return

#defcfunc negi_lang_extern_arg_len

	if s_extern_frame_array_i < 0 {
		return 0
	}
	return s_array_lens(s_extern_frame_array_i)

#defcfunc negi_lang_extern_arg_ty int index, \
	local cell_i

	if (0 <= index && index < negi_lang_extern_arg_len()) == false {
		return ty_int
	}
	cell_i = negi_lang_array_ref(ty_array, s_extern_frame_array_i, index)
	return s_cell_tys(cell_i)

#defcfunc negi_lang_extern_arg_int int index, \
	local cell_i

	if (0 <= index && index < negi_lang_extern_arg_len()) == false {
		return 0
	}
	cell_i = negi_lang_array_ref(ty_array, s_extern_frame_array_i, index)
	return s_cell_vals(cell_i)

#defcfunc negi_lang_extern_arg_str int index, \
	local cell_i

	if (0 <= index && index < negi_lang_extern_arg_len()) == false {
		return 0
	}
	cell_i = negi_lang_array_ref(ty_array, s_extern_frame_array_i, index)
	return s_strs(s_cell_vals(cell_i))

// 組み込み関数専用。
#deffunc negi_lang_extern_result_any int ty, int val

	if s_extern_frame_result < 0 { return }
	s_cell_tys(s_extern_frame_result) = ty
	s_cell_vals(s_extern_frame_result) = val
	return

#deffunc negi_lang_extern_result_int int val

	negi_lang_extern_result_any ty_int, val
	return

#deffunc negi_lang_extern_result_str var it

	negi_lang_extern_result_any ty_str, negi_lang_str_add(it)
	return

#deffunc negi_lang_extern_result_err str message

	s_extern_frame_err = true
	s_extern_frame_err_message = message
	return

// -----------------------------------------------
// 評価
// -----------------------------------------------

#deffunc negi_lang_eval_initialize

	// プログラムカウンタ (次に実行するコマンド番号)
	s_pc = 0

	// 次の命令の前に GC を実行するか否か。
	s_gc_force = false

	// 終了コード
	s_eval_exit = 0
	return

// 異常終了する。
#deffunc negi_lang_eval_abort str message, int tok_i

	negi_lang_err_add message, s_tok_src_ls(tok_i), s_tok_src_rs(tok_i)

	// 終了コード 1 で停止させる。
	negi_lang_stack_push ty_int, 1
	s_pc = s_cmd_len - 1
	assert s_cmd_kinds(s_pc) == cmd_exit
	return

// エラー命令を処理する。
#deffunc negi_lang_eval_err int cmd_i

	assert s_cmd_kinds(cmd_i) == cmd_err
	negi_lang_eval_abort s_cmd_strs(cmd_i), s_cmd_tok_is(cmd_i)
	return

#deffunc negi_lang_eval_push_array int cmd_i, \
	local array_i, local len, local elem_ty, local elem_val

	assert s_cmd_kinds(cmd_i) == cmd_push_array
	len = s_cmd_xs(cmd_i)

	array_i = negi_lang_array_add(0, len)
	negi_lang_stack_push ty_array, array_i
	return

#deffunc negi_lang_eval_push_closure int cmd_i, \
	local fun_i, local env_i, local closure_i

	fun_i = s_cmd_xs(cmd_i)
	env_i = s_frame_env_is(s_frame_len - 1)
	closure_i = negi_lang_closure_add(fun_i, env_i)

	negi_lang_stack_push ty_closure, closure_i
	return

#deffunc negi_lang_eval_local_var int cmd_i, \
	local index, local scope_i, local env_i

	assert s_cmd_kinds(cmd_i) == cmd_local_var
	index = s_cmd_xs(cmd_i)
	scope_i = s_cmd_ys(cmd_i)

	env_i = s_frame_env_is(s_frame_len - 1)

	negi_lang_stack_push ty_cell, negi_lang_env_ref(env_i, index, scope_i)
	return

#deffunc negi_lang_eval_cell_get int cmd_i, \
	local cell_ty, local cell_val, local item_ty, local item_val

	assert s_cmd_kinds(cmd_i) == cmd_cell_get

	negi_lang_stack_pop cell_ty, cell_val
	if cell_ty != ty_cell {
		negi_lang_eval_abort "左辺値が必要です。", s_cmd_tok_is(cmd_i)
		return
	}

	negi_lang_stack_push s_cell_tys(cell_val), s_cell_vals(cell_val)
	return

#deffunc negi_lang_eval_cell_set int cmd_i, \
	local cell_ty, local cell_val, local item_ty, local item_val

	assert s_cmd_kinds(cmd_i) == cmd_cell_set

	negi_lang_stack_pop item_ty, item_val
	negi_lang_stack_pop cell_ty, cell_val

	if cell_ty != ty_cell {
		negi_lang_eval_abort "左辺値が必要です。", s_cmd_tok_is(cmd_i)
		return
	}
	s_cell_tys(cell_val) = item_ty
	s_cell_vals(cell_val) = item_val

	negi_lang_stack_push item_ty, item_val
	return

#deffunc negi_lang_eval_jump_unless int cmd_i, \
	local cond_ty, local cond_val, local label_i

	assert s_cmd_kinds(cmd_i) == cmd_jump_unless
	label_i = s_cmd_xs(cmd_i)

	negi_lang_stack_pop cond_ty, cond_val
	if cond_ty != ty_int {
		negi_lang_eval_abort "条件の型が不正です。", s_cmd_tok_is(cmd_i)
		return
	}

	if cond_val == false {
		s_pc = s_label_cmd_is(label_i)
		assert s_cmd_kinds(s_pc) == cmd_label
	}
	return

// スワップ命令を処理する。スタックの上の2つの要素の順番を入れ替える。
#deffunc negi_lang_eval_swap int cmd_i, \
	local val_l, local val_r, local ty_l, local ty_r

	assert s_cmd_kinds(cmd_i) == cmd_swap
	negi_lang_stack_pop ty_l, val_l
	negi_lang_stack_pop ty_r, val_r
	negi_lang_stack_push ty_l, val_l
	negi_lang_stack_push ty_r, val_r
	return

#deffunc negi_lang_eval_dup int cmd_i, \
	local ty, local val

	assert s_cmd_kinds(cmd_i) == cmd_dup
	negi_lang_stack_pop ty, val
	negi_lang_stack_push ty, val
	negi_lang_stack_push ty, val
	return

#deffunc negi_lang_eval_call int cmd_i, \
	local len, local call_tok_i, local i, \
	local fun_ty, local fun_val, local arg_tys, local arg_vals, \
	local fun_i, local closure_i, local body_label_i, local array_i, local parent_env_i, local env_i, \
	local extern_fun_i, local result_cell_l, local result_cell_r

	assert s_cmd_kinds(cmd_i) == cmd_call
	len = s_cmd_xs(cmd_i)
	call_tok_i = s_cmd_tok_is(cmd_i)

	dim arg_tys, len
	dim arg_vals, len
	repeat len
		i = len - 1 - cnt
		negi_lang_stack_pop arg_tys(i), arg_vals(i)
	loop
	negi_lang_stack_pop fun_ty, fun_val

	// クロージャを呼び出す。
	if fun_ty == ty_closure {
		closure_i = fun_val
		fun_i = s_closure_fun_is(closure_i)
		parent_env_i = s_closure_env_is(closure_i)
		body_label_i = s_fun_label_is(fun_i)

		assert s_fun_kinds(fun_i) == fun_kind_closure

		// 環境を生成して、実引数を割り当てる。
		env_i = negi_lang_env_add(parent_env_i, fun_i)

		array_i = s_env_array_is(env_i)
		repeat len
			negi_lang_array_set ty_array, array_i, cnt, arg_tys(cnt), arg_vals(cnt)
		loop

		negi_lang_frame_push s_pc, env_i, call_tok_i
		s_pc = s_label_cmd_is(body_label_i)
		return
	}

	// 外部関数を呼び出す。
	if fun_ty == ty_extern {
		extern_fun_i = fun_val

		array_i = negi_lang_array_add(len, len)
		negi_lang_heap_alloc 1, result_cell_l, result_cell_r

		repeat len
			negi_lang_array_set ty_array, array_i, cnt, arg_tys(cnt), arg_vals(cnt)
		loop

		s_extern_frame_err = false
		s_extern_frame_array_i = array_i
		s_extern_frame_result = result_cell_l

		gosub s_extern_fun_labels(extern_fun_i)
		if s_extern_frame_err != false {
			negi_lang_eval_abort s_extern_frame_err_message, call_tok_i
		} else {
			negi_lang_stack_push s_cell_tys(s_extern_frame_result), s_cell_vals(s_extern_frame_result)
		}

		s_extern_frame_err = false
		s_extern_frame_array_i = -1
		s_extern_frame_result = -1
		return
	}

	negi_lang_eval_abort "type error", call_tok_i
	return

#deffunc negi_lang_eval_return int cmd_i

	assert s_cmd_kinds(cmd_i) == cmd_return
	s_pc = negi_lang_frame_pop()
	return

// スタック上の2つの値に演算を適用し、結果をスタックに置く。
#deffunc negi_lang_eval_op int cmd_i, int op, \
	local ty, local val_l, local ty_r, local val_r, local ty_t, local val_t

	negi_lang_stack_pop ty_r, val_r
	negi_lang_stack_pop ty, val_l

	assert op != op_semi

	if op == op_eq {
		if ty != ty_r {
			negi_lang_stack_push ty_int, false
			return
		}
		if ty == ty_int {
			negi_lang_stack_push ty_int, val_l == val_r
			return
		}
		if ty == ty_str {
			negi_lang_stack_push ty_int, s_strs(val_l) == s_strs(val_r)
			return
		}
		negi_lang_eval_abort "type error", s_cmd_tok_is(cmd_i)
		return
	}
	assert op != op_ne
	if op == op_lt {
		if ty != ty_r {
			negi_lang_stack_push ty_int, ty < ty_r
			return
		}
		if ty == ty_int {
			negi_lang_stack_push ty_int, val_l < val_r
			return
		}
		if ty == ty_str {
			negi_lang_stack_push ty_int, (s_strs(val_l) != s_strs(val_r)) < 0
			return
		}
		negi_lang_eval_abort "type error", s_cmd_tok_is(cmd_i)
		return
	}
	assert op != op_le
	assert op != op_gt
	assert op != op_ge

	if op == op_index {
		if ty == ty_str && ty_r == ty_int {
			// FIXME: オーバーフローエラーを検出する
			negi_lang_stack_push ty_int, peek(s_strs(val_l), val_r)
			return
		}
		if ty == ty_array && ty_r == ty_int {
			negi_lang_array_get ty, val_l, val_r, ty_t, val_t
			negi_lang_stack_push ty_t, val_t
			return
		}
		negi_lang_eval_abort "type error", s_cmd_tok_is(cmd_i)
		return
	}
	if op == op_index_ref {
		if ty == ty_array && ty_r == ty_int {
			negi_lang_stack_push ty_cell, negi_lang_array_ref(ty, val_l, val_r)
			return
		}
		negi_lang_eval_abort "type error", s_cmd_tok_is(cmd_i)
		return
	}
	if op == op_array_push {
		assert ty == ty_array
		negi_lang_array_push ty, val_l, ty_r, val_r
		negi_lang_stack_push ty, val_l
		return
	}

	if ty != ty_r {
		negi_lang_eval_abort "type error", s_cmd_tok_is(cmd_i)
		return
	}

	if op == op_add {
		if ty == ty_int {
			negi_lang_stack_push ty_int, val_l + val_r
			return
		}
		if ty == ty_str {
			val_l = negi_lang_str_add(s_strs(val_l) + s_strs(val_r))
			negi_lang_stack_push ty_str, val_l
			return
		}
		negi_lang_eval_abort "type error", s_cmd_tok_is(cmd_i)
		return
	}
	if op == op_sub {
		if ty == ty_int {
			negi_lang_stack_push ty_int, val_l - val_r
			return
		}
		negi_lang_eval_abort "type error", s_cmd_tok_is(cmd_i)
		return
	}
	if op == op_mul {
		if ty == ty_int {
			negi_lang_stack_push ty_int, val_l * val_r
			return
		}
		negi_lang_eval_abort "type error", s_cmd_tok_is(cmd_i)
		return
	}
	if op == op_div {
		if ty == ty_int {
			negi_lang_stack_push ty_int, val_l / val_r
			return
		}
		negi_lang_eval_abort "type error", s_cmd_tok_is(cmd_i)
		return
	}
	if op == op_mod {
		if ty == ty_int {
			negi_lang_stack_push ty_int, val_l \ val_r
			return
		}
		negi_lang_eval_abort "type error", s_cmd_tok_is(cmd_i)
		return
	}

	d_trace "op = " + op
	failwith "Unknown op"

// 評価のメインループ。
// 終了命令に到達するまで、命令のリストを1つずつ実行する。
#deffunc negi_lang_eval_main \
	local cmd_i, local ty, local val

	repeat
		if s_gc_force {
			negi_lang_gc_run
		}

		cmd_i = s_pc
		s_pc++

		if s_cmd_kinds(cmd_i) == cmd_push_int {
			negi_lang_stack_push ty_int, s_cmd_xs(cmd_i)
			continue
		}
		if s_cmd_kinds(cmd_i) == cmd_push_str {
			negi_lang_stack_push ty_str, negi_lang_str_add(s_cmd_strs(cmd_i))
			continue
		}
		if s_cmd_kinds(cmd_i) == cmd_push_array {
			negi_lang_eval_push_array cmd_i
			continue
		}
		if s_cmd_kinds(cmd_i) == cmd_push_closure {
			negi_lang_eval_push_closure cmd_i
			continue
		}
		if s_cmd_kinds(cmd_i) == cmd_push_extern {
			negi_lang_stack_push ty_extern, s_cmd_xs(cmd_i)
			continue
		}
		if s_cmd_kinds(cmd_i) == cmd_local_var {
			negi_lang_eval_local_var cmd_i
			continue
		}
		if s_cmd_kinds(cmd_i) == cmd_cell_get {
			negi_lang_eval_cell_get cmd_i
			continue
		}
		if s_cmd_kinds(cmd_i) == cmd_cell_set {
			negi_lang_eval_cell_set cmd_i
			continue
		}
		if s_cmd_kinds(cmd_i) == cmd_jump_unless {
			negi_lang_eval_jump_unless cmd_i
			continue
		}
		if s_cmd_kinds(cmd_i) == cmd_pop {
			negi_lang_stack_pop ty, val
			continue
		}
		if s_cmd_kinds(cmd_i) == cmd_swap {
			negi_lang_eval_swap cmd_i
			continue
		}
		if s_cmd_kinds(cmd_i) == cmd_dup {
			negi_lang_eval_dup cmd_i
			continue
		}
		if s_cmd_kinds(cmd_i) == cmd_call {
			negi_lang_eval_call cmd_i
			continue
		}
		if s_cmd_kinds(cmd_i) == cmd_return {
			negi_lang_eval_return cmd_i
			continue
		}
		if s_cmd_kinds(cmd_i) == cmd_op {
			negi_lang_eval_op cmd_i, s_cmd_xs(cmd_i)
			continue
		}
		if s_cmd_kinds(cmd_i) == cmd_err {
			negi_lang_eval_err cmd_i
			continue
		}
		if s_cmd_kinds(cmd_i) == cmd_exit {
			// スタックの値を終了コードとする。
			negi_lang_stack_pop ty, s_eval_exit
			if ty != ty_int {
				negi_lang_eval_abort "計算結果は整数値でなければいけません。", s_cmd_tok_is(cmd_i)
				continue
			}
			break
		}
		if s_cmd_kinds(cmd_i) == cmd_label {
			continue
		}

		d_trace "cmd_kind = " + s_cmd_kinds(cmd_i)
		failwith "Unknown cmd_kind"
	loop
	return

#deffunc negi_lang_eval \
	local global_var_len, local array_i, local exit_cmd_i

	negi_lang_eval_initialize

	assert s_cmd_len != 0

	exit_cmd_i = s_cmd_len - 1
	assert s_cmd_kinds(exit_cmd_i) == cmd_exit

	// グローバル環境を生成する。
	s_env_i_global = negi_lang_env_add(-1, s_fun_i_main)
	negi_lang_frame_push exit_cmd_i, s_env_i_global, 0

	negi_lang_eval_main
	return

// ###############################################
// ガベージコレクション
// ###############################################

// 詳細は README のガベージコレクションの節を参照。

#deffunc negi_lang_gc_run \
	local stuck

	d_trace "GC run"

	// GC 用の変数を初期化する。
	negi_lang_cell_gc_begin
	negi_lang_array_gc_begin
	negi_lang_env_gc_begin

	// 生きているオブジェクトにマークをつける。
	negi_lang_cell_gc_mark_stack
	negi_lang_frame_gc_mark_all
	negi_lang_env_gc_mark_all

	repeat
		stuck = true

		negi_lang_cell_gc_mark_loop stuck
		negi_lang_array_gc_mark_loop stuck

		if stuck { break }
	loop

	// 生きているオブジェクトを再配置する。
	negi_lang_cell_gc_move
	negi_lang_array_gc_move

	// 要素番号を書き換える。
	negi_lang_cell_gc_rewrite_all
	negi_lang_array_gc_rewrite_all
	negi_lang_env_gc_rewrite_all

	s_gc_force = false
	return

// ###############################################
// 実行
// ###############################################

#deffunc negi_lang_initialize

	negi_lang_extern_fun_initialize
	return

// ソースコードをコンパイル・実行する。
#deffunc negi_lang_eval_src str param_src, var out_exit_code, \
	local src

	src = param_src

	negi_lang_src_initialize src
	negi_lang_err_initialize
	negi_lang_tok_initialize
	negi_lang_exp_initialize
	negi_lang_subexp_initialize
	negi_lang_label_initialize
	negi_lang_scope_initialize
	negi_lang_local_initialize
	negi_lang_loop_initialize
	negi_lang_fun_initialize
	negi_lang_cmd_initialize
	negi_lang_cell_initialize
	negi_lang_frame_initialize
	negi_lang_str_initialize
	negi_lang_array_initialize
	negi_lang_env_initialize
	negi_lang_closure_initialize
	negi_lang_extern_frame_initialize

	negi_lang_tokenize
	negi_lang_parse
	negi_lang_gen
	negi_lang_eval
	out_exit_code = s_eval_exit
	return

// ###############################################
// 組み込み関数
// ###############################################

#define x_args s_extern_frame_array_i

#define x_argc s_array_lens(x_args)

#define ctype x_arg_ty(%1) s_cell_tys(s_array_cell_ls(x_args) + (%1))

#define ctype x_arg_val(%1) s_cell_vals(s_array_cell_ls(x_args) + (%1))

#deffunc negi_lang_extern_fun_builtin

	negi_lang_extern_fun_add "int_to_str", *l_int_to_str
	negi_lang_extern_fun_add "array_len", *l_array_len
	negi_lang_extern_fun_add "array_push", *l_array_push
	negi_lang_extern_fun_add "hsp3_mes", *l_hsp3_mes
	negi_lang_extern_fun_add "__dev_heap_make_tiny", *l_dev_heap_make_tiny
	return

*l_int_to_str

	if x_argc != 1 || x_arg_ty(0) != ty_int {
		negi_lang_extern_result_err "int_to_str error"
		return
	}
	negi_lang_extern_result_any ty_str, negi_lang_str_add(str(x_arg_val(0)))
	return

*l_array_len

	if x_argc != 1 || x_arg_ty(0) != ty_array {
		negi_lang_extern_result_err "array_len error"
		return
	}
	negi_lang_extern_result_any ty_int, s_array_lens(x_arg_val(0))
	return

*l_array_push

	if x_argc != 2 || x_arg_ty(0) != ty_array {
		negi_lang_extern_result_err "array_push error"
		return
	}
	negi_lang_array_push x_arg_ty(0), x_arg_val(0), x_arg_ty(1), x_arg_val(1)
	negi_lang_extern_result_any ty_array, x_arg_val(0)
	return

*l_hsp3_mes

	if x_argc != 1 {
		negi_lang_extern_result_err "mes error"
		return
	}
	if x_arg_ty(0) == ty_int {
		mes x_arg_val(0)
	} else : if x_arg_ty(0) == ty_str {
		mes s_strs(x_arg_val(0))
	} else {
		logmes "unknown type " + (x_arg_ty(0) - ty_int)
	}

	negi_lang_extern_result_int 0
	return

*l_dev_heap_make_tiny

	s_gc_threshold = 24
	s_cell_len = s_cell_i_heap_end + s_gc_threshold + 48
	negi_lang_extern_result_any ty_int, 0
	return

#global

	negi_lang_initialize
